<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2023/04/12/leetcode_recod/"/>
    <url>/2023/04/12/leetcode_recod/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">快乐数</a></h3><p>​编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p>示例：</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">输入：n = </span><span class="hljs-number">19</span><span class="language-xml"></span><br><span class="language-xml">输出：true</span><br><span class="language-xml">解释：</span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">9</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">82</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">2</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">68</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">6</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">100</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>题目有提示：如果出现无限循环，意味着相同的数出现两次。</p><p>所以我们可以用<code>HashSet</code>记录出现的中间值，如果有中间值出现两次以上就肯定不是快乐数</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        HashSet&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>( n != <span class="hljs-number">1</span> &amp;&amp; !hashSet.contains(n))&#123;<br>            hashSet.add(n);<br>            n = getNext(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> n )</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            ans += (n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>出现循环的数，可以联想到环行链表，那么我们可以使用快慢指针来解决。</p><p>如果没有出现循环，即快指针最后指向的是1，那么1的平方和也是1。</p><p>如果出现循环，那么快慢指针会相遇。</p><p><img src="https://assets.leetcode-cn.com/solution-static/202/202_fig2.png" alt="fig2"></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> fast=n;<br>        <span class="hljs-type">int</span> slow=n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow=squareSum(slow);<br>            fast=squareSum(fast);<br>            fast=squareSum(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow!=fast);<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">squareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>&#123;<br>        <span class="hljs-type">int</span> squaresum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(m!=<span class="hljs-number">0</span>)&#123;<br>           squaresum+=(m%<span class="hljs-number">10</span>)*(m%<span class="hljs-number">10</span>);<br>            m/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> squaresum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存在重复元素-III"><a href="#存在重复元素-III" class="headerlink" title="存在重复元素 III"></a><a href="https://leetcode.cn/problems/contains-duplicate-iii/description/">存在重复元素 III</a></h3><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p><p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">t</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">t</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">t</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 2 * 1e4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= t &lt;= 2^31 -1 </code></li></ul><blockquote><p>思路：</p><p>根据题意：我们要满足的两个条件 ：</p><ol><li><strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code></li><li><code>abs(i - j) &lt;= k</code> 。</li></ol><p>翻译一下：就是在区间<code>[max(0,i-k),i]</code>中任一值u，找到一个值在<code>[u-t,u+t]</code>这个范围内。</p><p>我们需要一个数据结构，能够支持维护一个有序的序列， 并且查找的性能很优异，能够快速查找到小于等于u的最大值，和大于等于u的最小值。</p><p>因此我们可以使用<code>TreeSet</code>即有序集合。</p></blockquote><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 使用Long是因为数值有点大否则会溢出</span><br>        TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> nums[i] * <span class="hljs-number">1L</span>;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> set.floor(u);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> set.ceiling(u);<br>            <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span> &amp;&amp; u-l &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(h != <span class="hljs-literal">null</span> &amp;&amp; h-u &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            set.add(u);<br>            <span class="hljs-keyword">if</span>(i &gt;= k) set.remove(nums[i-k]*<span class="hljs-number">1L</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><h3 id="寻找重复数Ⅰ（耻辱）-字节medium"><a href="#寻找重复数Ⅰ（耻辱）-字节medium" class="headerlink" title="寻找重复数Ⅰ（耻辱）  [字节medium]"></a>寻找重复数Ⅰ（耻辱）  [字节medium]</h3><p>给定一个包含 <code>n + 1 </code>个整数的数组 <code>nums </code>，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设<code>nums</code><strong>只有 一个重复</strong>的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 只用<strong>常量级 O(1)</strong> 的额外空间。</p><blockquote><p>思路：</p><p>题目没有要求不修改数组的话，</p><p>可以使用哈希表，将原本数值<code>num</code>把下标为<code>num-1</code>的值修改为负数，如果遍历时发现<code>nums[num-1] &lt; 0</code>那么重复的值就是<code>num</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Math.abs(nums[i]);<br>            <span class="hljs-keyword">if</span>(nums[num-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums[num-<span class="hljs-number">1</span>] *= -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同理，还可以把这个数组重新“排序一下”，因为这个数组的长度为n，然后数组的值只会在[1,n]里出现，那么就可以把对应值<code>num</code>放到它应该在的下标<code>num-1</code>。这也是这类题的模板做法</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// int num = nums[i];</span><br>            <span class="hljs-keyword">while</span> (nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                swap(nums, nums[i]-<span class="hljs-number">1</span>, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] - <span class="hljs-number">1</span>!=i)&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缺少的第一个正整数（耻辱）-字节hard"><a href="#缺少的第一个正整数（耻辱）-字节hard" class="headerlink" title="缺少的第一个正整数（耻辱）  [字节hard]"></a>缺少的第一个正整数（耻辱）  [字节hard]</h3><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><ul><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><blockquote><p>哈希表：</p><p>我们可以借鉴上题的做法。但是要对原数组做一些预处理：</p><p>因为要求返回的是第一个正整数，那么这个正整数的范围肯定在[1,n+1]其中n是数组的长度。</p><p>但是题目给的数组中的元素的值不一定在这个范围内，所以要对不在这个范围内的值做一些处理</p><ul><li>首先对于大于N的数，我们可以不做处理，因为他们并不影响缺少的第一个正整数。</li><li>然后对于小于等于0的数，我们可以给他们做个标记，修改他们的值为N+1</li><li>然后对于在[1,N]内的值，我们把他们的值x对于x-1的下标值标记为<code>-abs(nums[x-1])</code>。比如对于数字1，把数组的第一个数（下标为1-1）标记为负数，对于数字2，把数组的第二个数标记为负数。那么对于没有出现的数字i，在第i位的数字肯定大于0，转换成下标就是如果<code>nums[i] &gt; 0</code>则i+1没有出现。</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 原地哈希</span><br>        <span class="hljs-comment">// 把负数的地方修改成N+1</span><br>        <span class="hljs-comment">// 把[1,N]的值修改成负的绝对值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= <span class="hljs-number">0</span>)&#123;<br>                nums[i] = N+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Math.abs(n);<br>            <span class="hljs-keyword">if</span>(idx &lt;= N)&#123;<br>                nums[idx-<span class="hljs-number">1</span>] = -Math.abs(nums[idx-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> N+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原地哈希：</p><p>根据数字的特殊性，我们可以把第n个数放到它本该去的位置下标，即n-1。比如3，那么它是第3个数，它应该到3-1&#x3D;2的下标的位置。</p><p>如何实现这个把数值x放到它应该在的第n个数呢？</p><p>对于遍历到的数x &#x3D; <code>nums[i]</code>,如果<code>nums[x-1] != nums[i]</code>则要进行交换，在完成交换后，新的 <code>nums[i]</code> 可能还在[1,N] 的范围内，我们需要继续进行交换操作，直到 x不属于[1,N]。</p><p>注意到上面的方法可能会陷入死循环。如果<code>nums[i]</code> 恰好与 <code>nums[x−1]</code> 相等，那么就会无限交换下去。此时我们有<code>nums[i]=x=nums[x−1]</code>，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 原地哈希</span><br>        <span class="hljs-comment">// 把负数的地方修改成N+1</span><br>        <span class="hljs-comment">// 把[1,N]的值修改成负的绝对值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= N &amp;&amp; nums[nums[i]-<span class="hljs-number">1</span>] != nums[i])&#123;<br>                swap(nums, nums[i]-<span class="hljs-number">1</span>, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            <span class="hljs-keyword">if</span>( i+<span class="hljs-number">1</span> != nums[i])&#123;<br>                <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> N+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="丢失的数字"><a href="#丢失的数字" class="headerlink" title="丢失的数字"></a><a href="https://leetcode.cn/problems/missing-number/description/">丢失的数字</a></h3><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><ul><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,0,1]</span><br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,3]</span> 内。2 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：1<br>解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 <span class="hljs-comment">[0,1]</span> 内。1 是丢失的数字，因为它没有出现在 nums 中。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>根据数组中元素的特殊性，数值x应该映射到数组的下标为x表示它是第几个值。</p><p>所以我们要对数组做处理，把数组中数值x不在下标x的值做交换。直到数组中的每个数字都在相应的位置才行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &lt; n &amp;&amp; nums[i]!= i)&#123;<br>                swap(nums, i, nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i ) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a>找到所有数组中消失的数字</h3><p>给你一个含 n 个整数的数组<code>nums</code>，其中 <code>nums[i]</code> 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在<code>nums</code>中的数字，并以数组的形式返回结果。、</p><p>链接：<a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array</a></p><p>示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,3,2,7</span>,<span class="hljs-number">8,2,3,1</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>哈希表：和寻找重复数以及缺少的第一个正整数一样，因为数组中的值所在范围是[1,n]。</p><p>每次遍历值x，将下标x-1处的值置为负数。</p><p>然后再遍历数组，如果某个位置的值为正数，那么就是缺少了i+1这个值</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Math.abs(nums[i]);<br>            nums[idx-<span class="hljs-number">1</span>] = -Math.abs(nums[idx-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                ans.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组中重复的数据"><a href="#数组中重复的数据" class="headerlink" title="数组中重复的数据"></a><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/">数组中重复的数据</a></h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,3,2,7</span>,<span class="hljs-number">8,2,3,1</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>正负号哈希标记：和找到所有数组中消失的数字一样，把每次遍历值x，将下标x-1处的值置为负数。如果某个下标为0，那么这个x就是重复的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Math.abs(nums[i]);<br>            <span class="hljs-keyword">if</span>(nums[idx-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                ans.add(idx);<br>            &#125;<br>            nums[idx-<span class="hljs-number">1</span>] = -Math.abs(nums[idx-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：和缺少的第一个正整数一样</p><p>把<code>nums</code>中的数放到它应该待的地方。</p><ul><li>如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i−1 的位置即可；</li><li>如果 i 出现了两次，那么我们希望其中的一个 ii 放在数组下标中为 i−1 的位置，另一个 i 放置在任意「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] != nums[nums[i]-<span class="hljs-number">1</span>])&#123;<br>                swap(nums, i, nums[i]-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]-<span class="hljs-number">1</span>!=i)&#123;<br>                ans.add(nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>        nums[index1] = nums[index2];<br>        nums[index2] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a><a href="https://leetcode.cn/problems/array-nesting/">数组嵌套</a></h3><p>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中<code> S[i] = &#123;A[i], A[A[i]], A[A[A[i]]], ... &#125;</code>且遵守以下的规则。</p><p>假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是<code>A[A[i]]</code>，之后是<code>A[A[A[i]]]...</code> 以此类推，不断添加直到S出现重复的元素。</p><p> 示例 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: A = <span class="hljs-comment">[5,4,0,3,1,6,2]</span><br>输出: 4<br>解释: <br>A<span class="hljs-comment">[0]</span> = 5, A<span class="hljs-comment">[1]</span> = 4, A<span class="hljs-comment">[2]</span> = 0, A<span class="hljs-comment">[3]</span> = 3, A<span class="hljs-comment">[4]</span> = 1, A<span class="hljs-comment">[5]</span> = 6, A<span class="hljs-comment">[6]</span> = 2.<br><br>其中一种最长的 S<span class="hljs-comment">[K]</span>:<br>S<span class="hljs-comment">[0]</span> = &#123;A<span class="hljs-comment">[0]</span>, A<span class="hljs-comment">[5]</span>, A<span class="hljs-comment">[6]</span>, A<span class="hljs-comment">[2]</span>&#125; = &#123;5, 6, 2, 0&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>和之前的寻找重复的数一样，我们可以把下标i和nums[i]连起来作为一个有向图。</p><p>由于题目保证 nums 中不含有重复的元素，因此有向图中每个点的出度和入度均为 1。</p><p>在这种情况下，有向图必然由一个或多个环组成。我们可以遍历 nums，找到节点个数最大的环。</p><p>代码实现时需要用一个vis 数组来标记访问过的节点。</p><p>或者使用标记法，如果访问过的数就标记为-1，这样可以减少空间复杂度。</p><p><img src="/leetcode_recod.assets/1657986879-DaxDHi-image.png" alt="image.png"></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayNesting</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(nums[i]!= -<span class="hljs-number">1</span> )&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = -<span class="hljs-number">1</span>;<br>                i = tmp;<br>                cnt++;<br>            &#125;<br>            ans = Math.max(ans,cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前K个高频单词"><a href="#前K个高频单词" class="headerlink" title="前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/description/">前K个高频单词</a></h3><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: words = [<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;coding&quot;</span>], k = <span class="hljs-number">2</span><br>输出: [<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>]<br>解析: <span class="hljs-string">&quot;i&quot;</span> 和 <span class="hljs-string">&quot;love&quot;</span> 为出现次数最多的两个单词，均为<span class="hljs-number">2</span>次。<br>    注意，按字母顺序 <span class="hljs-string">&quot;i&quot;</span> 在 <span class="hljs-string">&quot;love&quot;</span> 之前。<br>    <br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>哈希+排序</p><p>哈希表统计出现频率</p><p>然后排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">topKFrequent</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;String, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str:words)&#123;<br>            count.put(str, count.getOrDefault(str, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(count.keySet());<br>        ans.sort((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(count.get(o1).equals(count.get(o2)))&#123;<br>                <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> count.get(o2)-count.get(o1);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> ans.subList(<span class="hljs-number">0</span>, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="无重复字符的最长子串-字节-medium"><a href="#无重复字符的最长子串-字节-medium" class="headerlink" title="无重复字符的最长子串 [字节 medium]"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a> [字节 medium]</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><blockquote><p>哈希表+滑动窗口</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(n  &lt; <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">129</span>];<br>        <span class="hljs-keyword">for</span>(; r &lt; n; r++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.charAt(r);<br>            hash[idx]++;<br>            <span class="hljs-keyword">while</span>(hash[idx] &gt; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.charAt(l);<br>                hash[i]--;<br>                l++;<br>            &#125;<br>            res = Math.max(res, r-l+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>哈希集合+滑动窗口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(n  &lt; <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>)&#123;<br>                set.remove(s.charAt(i-<span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">while</span>(r + <span class="hljs-number">1</span> &lt; n &amp;&amp; !set.contains(s.charAt(r+<span class="hljs-number">1</span>)))&#123;<br>                set.add(s.charAt(r+<span class="hljs-number">1</span>));<br>                r++;<br>            &#125;<br>            res = Math.max(res, r-i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>更巧妙的做法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 记录字符上一次出现的位置</span><br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">128</span>;i++)&#123;<br>            last[i] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化为-1；</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ind</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            left = Math.max(left,last[ind]+<span class="hljs-number">1</span>);<br>            res  = Math.max(res,i-left + <span class="hljs-number">1</span>);<br>            last[ind] = i; <span class="hljs-comment">// 妙啊</span><br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最小覆盖子串-字节hard"><a href="#最小覆盖子串-字节hard" class="headerlink" title="最小覆盖子串 [字节hard]"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a> [字节hard]</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>滑动窗口+哈希表</p><p>用一个哈希表+减法来记录t中的字符个数。即：<code>hash[t[i]]--</code>t中出现的字符在哈希表中用负数取记录。</p><p>遍历s字符串。</p><p>维护一个窗口，窗口中的字符串满足都包含t的所有字符。变量cnt来记录s子串中出现t字符的个数。</p><p>右指针遍历时。如果此时窗口内不满足包含t中所有字符串，则递增直到，窗口包含所有t的字符。</p><p>具体遍历操作：右指针遍历时：对哈希表对应位置+1 ，如果哈希表对应位置小于0 ，则还没包含所有t的字符，cnt+1。然后右指针自增。</p><p>如果此时子串已经包含t中所有位置。可以进行收缩，如果左指针对应位置的字符，在哈希表中的值是大于0 ，即不在t中，或者比t中字符的个数多了的情况，哈希表对应位置减一，然后左指针收缩。直到s中刚刚好包含t中所有字符。</p><p>然后更新答案即可。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m ; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            hash[c]--;<br>        &#125;<br>        <span class="hljs-comment">// 双指针维护滑动窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化最小长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> s.length()+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计数来判断是否包含t的所有字符</span><br>        <span class="hljs-type">int</span> cnt= <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;right &lt; s.length(); right++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            hash[idx]++;<br>            <span class="hljs-keyword">if</span>(hash[idx] &lt;= <span class="hljs-number">0</span>) cnt++;<br>            <span class="hljs-comment">// 如果左指针处的字符不在t中出现或者出现次数大于t中的字符出现次数，则收缩。</span><br>            <span class="hljs-comment">// 窗口内的字符满足题目的条件。</span><br>            <span class="hljs-keyword">while</span>(cnt == m &amp;&amp; hash[s.charAt(left)] &gt; <span class="hljs-number">0</span>  ) hash[s.charAt(left++)]--;<br>            <span class="hljs-keyword">if</span>(cnt == m)&#123;<br>                <span class="hljs-keyword">if</span>(right - left &lt; maxLen)&#123;<br>                    maxLen = right-left;<br>                    start=left;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen == s.length()+<span class="hljs-number">1</span>?<span class="hljs-string">&quot;&quot;</span>:s.substring(start,maxLen+start+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h3><p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。</p><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><p><strong>示例 ：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;AABABBA&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 <span class="hljs-string">&quot;AABBBBA&quot;</span>。<br>子串 <span class="hljs-string">&quot;BBBB&quot;</span> 有最长重复字母, 答案 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><blockquote><p>双指针&#x2F;滑动窗口：维护一个区间，这个区间满足，除了出现次数最多的字符以外，其它字符出现的个数<code>&lt;= k</code>。</p><p>如果不满足则收缩左部，如果满足则更新答案，移动右部，求得最大的区间长度。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span>[] cnt= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">27</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r= <span class="hljs-number">0</span>; r &lt; n ; r++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> cs[r]-<span class="hljs-string">&#x27;A&#x27;</span>;<br>            cnt[idx]++;<br>            <span class="hljs-keyword">while</span>(!check(cnt, k))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cs[l]-<span class="hljs-string">&#x27;A&#x27;</span>;<br>                cnt[i]--;<br>                l++;<br>            &#125;<br>            ans = Math.max(ans,r-l+<span class="hljs-number">1</span>);<br>        &#125;   <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cnt, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            max = Math.max(max,cnt[i]);<br>            sum+=cnt[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (sum - max) &lt;= k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a></h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><blockquote><p>双指针+滑动窗口：</p><p>先用哈希表记录s1出现的字符的次数。</p><p>然后遍历s2，维持一个窗口满足，窗口内只有出现s1的字符，并且次数一致。否则收缩左窗口。</p><p>当窗口长度为s1的长度时，返回true</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray();<br>        <span class="hljs-type">char</span>[] cs2 = s2.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cs2.length;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>            --hash[cs1[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;r &lt; m; r++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> cs2[r]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            hash[idx]++;<br>            <span class="hljs-keyword">while</span>(hash[idx] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cs2[l]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                hash[i]--;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(r - l  + <span class="hljs-number">1</span> == n )&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a></h3><p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>, words = [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">9</span>]<br>解释：<br>从索引 <span class="hljs-number">0</span> 和 <span class="hljs-number">9</span> 开始的子串分别是 <span class="hljs-string">&quot;barfoo&quot;</span> 和 <span class="hljs-string">&quot;foobar&quot;</span> 。<br>输出的顺序不重要, [<span class="hljs-number">9</span>,<span class="hljs-number">0</span>] 也是有效答案。<br></code></pre></td></tr></table></figure><blockquote><p>滑动窗口+哈希表</p><p>哈希表<code>map</code>记录words中出现的次数和单词。</p><p>然后优化起点的遍历，我们可以根据当前下标和单词长度取余的结果来遍历，这样可以减少新建哈希表的消耗。</p><p>对取余相同的位置，我们用保持长度为m*w的滑动窗口来进行词频统计。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = words.length, w = words[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-comment">// 统计 words 中「每个目标单词」的出现次数</span><br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; w; i++) &#123;<br>            <span class="hljs-comment">// 构建一个当前子串对应 map，统计当前子串中「每个目标单词」的出现次数</span><br>            Map&lt;String, Integer&gt; curMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 滑动窗口的大小固定是 m * w</span><br>            <span class="hljs-comment">// 每次将下一个单词添加进 cur，上一个单词移出 cur</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j + w &lt;= n; j += w) &#123;   <br>                <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> s.substring(j, j + w);<br>                <span class="hljs-keyword">if</span> (j &gt;= i + (m * w)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> j - m * w;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> s.substring(idx, idx + w);<br>                    <span class="hljs-keyword">if</span> (curMap.get(prev) == <span class="hljs-number">1</span>) curMap.remove(prev);    <br>                    <span class="hljs-keyword">else</span> curMap.put(prev, curMap.get(prev) - <span class="hljs-number">1</span>);<br>                &#125;<br>                curMap.put(cur, curMap.getOrDefault(cur, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 如果当前子串对应 map 和 words 中对应的 map 相同，说明当前子串包含了「所有的目标单词」，将起始下标假如结果集</span><br>                <span class="hljs-keyword">if</span> (map.containsKey(cur) &amp;&amp; curMap.get(cur).equals(map.get(cur)) &amp;&amp; curMap.equals(map)) &#123;<br>                    ans.add(j - (m - <span class="hljs-number">1</span>) * w);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><blockquote><p>思路：哈希集合+一次遍历</p><p>我们先用哈希集合存储nums中的数字。</p><p>然后遍历数组，如果某个数字n在哈希集合中有n-1这个数，我们就跳过，这是为了避免重复计算。</p><p>如果没有n-1这个数，我们就看看集合中是否有n+1，n+2,…每有一个就递增长度。取最大的changdu 作为答案</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>            set.add(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(set.contains(nums[i]-<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                <span class="hljs-keyword">while</span>(set.contains(temp))&#123;<br>                    len++;<br>                    temp = temp+<span class="hljs-number">1</span>;<br>                &#125;<br>                ans = Math.max(ans,len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>判断题目是否适合使用二分查找法，主要是看条件是否满足二段性而不是单调性，即二分后能否判断答案所在的范围。</p><blockquote><p><code>leetbook</code>:</p><p>二分查找是一种在每次比较之后<em>将查找<strong>空间一分为二</strong></em>的算法。每次需要查找集合中的索引或元素时，都应该考虑二分查找。</p></blockquote><p>模板一：<strong>对应查找区间[left,right]</strong></p><ul><li>初始条件：left &#x3D; 0, right &#x3D; length-1</li><li>终止：left &gt; right</li><li>向左查找：right &#x3D; mid-1</li><li>向右查找：left &#x3D; mid+1</li></ul><p>这里是为了找到某个目标。</p><p>边界条件：</p><ul><li><p>left &lt;&#x3D; right </p><p>意味着在[left,right] 这个区间内是我们的目标范围，所以当右部不满足时，我们要<code>right = mid - 1</code>，左部不满足时，我们要<code>left = mid + 1</code></p></li><li><p>left &lt; right</p><p>意味着在[left,right)这个区间是我们的目标范围，所以右部不满足时，更新<code>right = mid</code>,左部不满足时，更新<code>left = mid+1</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>  <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>    <span class="hljs-comment">// Prevent (left + right) overflow</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] == target)&#123; <span class="hljs-keyword">return</span> mid; &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">else</span> &#123; right = mid - <span class="hljs-number">1</span>; &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// End Condition: left &gt; right</span><br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板二：<strong>对应查找区间[left, right)</strong></p><ul><li>一种实现二分查找的高级方法。</li><li>查找条件需要访问元素的直接右邻居。</li><li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li><li>保证查找空间在每一步中至少有 <strong>2 个元素</strong>。</li><li>需要进行后处理。 <strong>当你剩下 1 个元素时</strong>，循环 &#x2F; 递归结束。 需要评估剩余元素是否符合条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>  <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 不同点</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>  <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>    <span class="hljs-comment">// Prevent (left + right) overflow</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] == target)&#123; <span class="hljs-keyword">return</span> mid; &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">else</span> &#123; right = mid; &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Post-processing:</span><br>  <span class="hljs-comment">// End Condition: left == right</span><br>  <span class="hljs-keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target) <span class="hljs-keyword">return</span> left;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>程序中不要同时出现l &#x3D; mid, r &#x3D; mid这两条语句。</li><li>如过程序中出现了l &#x3D; mid，mid的值用 (l + r + 1) &#x2F; 2计算。 </li><li>如果程序中出现了r &#x3D; mid，mid的值用(l + r) &#x2F; 2计算。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回这个值第一次出现的地方</span><br><span class="hljs-comment">// 返回最解近某个值的上界，比如：最接近[1,2,3,4,5,6,8,9]求最接近7的值——返回8</span><br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/ <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] &gt;= t) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 返回这个值最后一次出现的地方</span><br><span class="hljs-comment">// 返回最解近某个值的下界，比如：最接近[1,2,3,4,5,6,8,9]求最接近7的值——返回6</span><br><span class="hljs-comment">// 返回满足某个条件的最大下标：见 长度最小的子数组</span><br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/ <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] &lt;= t) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板三：<strong>对应查找区间(left, right)</strong></p><ul><li>实现二分查找的另一种方法。</li><li>搜索条件需要访问元素的直接左右邻居。</li><li>使用元素的邻居来确定它是向右还是向左。</li><li>保证查找空间在每个步骤中至少有 <strong>3 个元素</strong>。</li><li>需要进行后处理。 <strong>当剩下 2 个元素时</strong>，循环 &#x2F; 递归结束。 需要评估其余元素是否符合条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right)&#123;<br>        <span class="hljs-comment">// Prevent (left + right) overflow</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Post-processing:</span><br>    <span class="hljs-comment">// End Condition: left + 1 == right</span><br>    <span class="hljs-keyword">if</span>(nums[left] == target) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">if</span>(nums[right] == target) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x的平方根（简单）"><a href="#x的平方根（简单）" class="headerlink" title="x的平方根（简单）"></a>x的平方根（简单）</h3><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><blockquote><p>思路：二分法，因为不是完全平方根时，要向下取整（如果是求完全平方根，那么要求x能整除mid），即当不满足left &gt; right 时跳出循环，返回的是right。 边界条件还是<code>left &lt;= righ</code>,因为如果<code>mid^2 &gt; x</code>，那么mid这个地方是不满足的，要往下走一位，而当 <code>mid ^ 2 &lt; x</code> 时，往前进一位，当然小于的时候可能包含想要的答案（<code>输入8时，2的平方小于8</code>)但是while中的&lt;&#x3D;避免了错过答案。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l+r &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(x / mid &lt; mid)&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x / mid &gt; mid)&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="搜索旋转数组"><a href="#搜索旋转数组" class="headerlink" title="搜索旋转数组"></a>搜索旋转数组</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; <code>nums.length</code>）上进行了 旋转，使数组变为<code> [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 target ，如果 <code>nums </code>中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><blockquote><p>思路：首先题目要求复杂度为O(log n),并且是搜索算法，那么自然而然地想到二分， 但是数组不是有序的，可以二分吗？</p><p>答案是可以的，因为有序不是二分算法的前提条件，而是能否通过二分确定答案所在的范围。</p><p>这道题是可以的。</p><p>如果<code>nums[mid] == target</code> 那么自然是返回mid</p><p>如果<code>nums[mid] != target</code> 时需要对数组的情况做个区分</p><blockquote><p>如果<code>nums[mid] &gt;= nums[0]</code>说明是从left到mid之间是递增的，然后需要判断目标值和左部的大小，如果<strong>目标值大于<code>nums[0]</code>并且严格小于<code>nums[mid]</code>，</strong>那么目标值所在的区间就是[left,mid-1]；否则，目标值就在[mid+1,right]之间。这里需要加上目标值和边界值的判断以确定答案所在的区间。</p></blockquote><blockquote><p>如果<code>nums[mid] &lt;= nums[0]</code>说明是从mid到right之间是递增的，同上，如果 **目标值小于<code>nums[n-1]</code>，并且严格大于<code>nums[mid]</code>**，那么可以确定目标值就在[mid+1,right]这个递增区间里。否则就在另一半区间内。</p></blockquote></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= nums[mid])&#123;<br>                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;<br>                    r = mid -<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[n - <span class="hljs-number">1</span>])&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="寻找旋转数组的最小值"><a href="#寻找旋转数组的最小值" class="headerlink" title="寻找旋转数组的最小值"></a>寻找旋转数组的最小值</h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]] </code>旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]] </code>。</p><p>给你一个元素值 互不相同 的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><blockquote><p>思路：时间复杂度为 O(log n) 并且是搜索算法，那么自然而然地想到二分查找</p><p>旋转数组。如果左部小于右部<code>nums[left] &lt; nums[right]</code>，那么这个数组就是正常的升序数组，直接返回左部即可</p><p>如果左部大于右部<code>nums[left] &gt; nums[right]</code>，那么发生了旋转。</p><p>进行中间和左部的判断 (和右部判断也可以) ，如果中间大于或等于左部<code>nums[mid] &gt;= nums[left]</code>，那么最小的一定在中间到右部<code>[mid+1,right]</code>这个位置</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[left] &lt; nums[right])&#123;<br>                <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[left])&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a>寻找旋转排序数组中的最小值 II</h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li><p>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]</p></li><li><p>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p></li></ul><p>给你一个可能存在 <strong>重复</strong> 元素值的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须尽可能减少整个过程的操作步骤。</p><blockquote><p>思路：</p><p>与上一题一样，同样是使用二分，</p><ul><li><p>如果<code>nums[left] &lt; nums[right]</code>说明数组是升序的直接返回左部即可</p></li><li><p>如果<code>nums[left] &gt;= nums[right]</code>说明数组是旋转的，我们需要比较<code>nums[mid] 和 nums[right]</code>为什么不比较左边界呢，因为旋转之前，右边界是最大的，而旋转之后，最小值到右边界是递增的部分，如果右边界小于左边界，那么比较中间值和右边界就可以容易找到最小值的所在区间。（比较左部也可以）。</p><ul><li>如果<code>nums[mid] &gt; nums[right]</code>那么最小值就在[mid+1, right]这里</li><li>如果<code>nums[mid] &lt; nums[right]</code>那么最小值就在[left, mid-1]这部分。</li><li>而当<code>nums[mid] == nums[right]</code>此时因为有 <strong>重复元素</strong>，我们无法判断最小值在哪半个区间 如:<code>[1 0 1 1 1]</code> 和 <code>[1 1 1 0 1]</code>，所以但是我们可以减少右边界，以缩小范围</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 和右部比较</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[left] &lt; nums[right])&#123;<br>               <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-comment">// 缩小范围</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == nums[right])&#123;<br>               right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums[mid] &lt; nums[right])&#123;<br>               right = mid;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>               left = mid + <span class="hljs-number">1</span>;<br>            &#125; <br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[left] ;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 和左部比较</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[left] &lt; nums[right])&#123;<br>                <span class="hljs-keyword">return</span> nums[left];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[left])&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[left])&#123;<br>                right = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;left++;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到-K-个最接近的元素"><a href="#找到-K-个最接近的元素" class="headerlink" title="找到 K 个最接近的元素"></a>找到 K 个最接近的元素</h3><p>给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p><p>整数 a 比整数 b 更接近 x 需要满足：</p><ul><li>|a - x| &lt; |b - x| 或者</li><li>|a - x| &#x3D;&#x3D; |b - x| 且 a &lt; b</li></ul><blockquote><p>思路1： 这题初看感觉使用优先队列来解决比较好。解决也很简单，但是由于返回结果要按升序来，效率就会很慢大概是<code>O(nlogn)</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findClosestElements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1-o2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(heap.size() &lt; k)&#123;<br>                heap.add(arr[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( Math.abs(heap.peek() -x) &gt; Math.abs(arr[i] - x))&#123;<br>                heap.poll();<br>                heap.add(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(heap).stream().sorted().collect(Collectors.toList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路2：其实这道题也可以使用二分查找来解决，因为数组是升序的，用二分查找找到离x最近的值（可以使用模板3，找到两个离x最近的值），然后中心扩散。时间效率大概是 <code>O(logn)+O(k)</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findClosestElements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 模板三做法</span><br>        <span class="hljs-keyword">while</span>(left  + <span class="hljs-number">1</span> &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left ) / <span class="hljs-number">2</span>; <br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; x )&#123;<br>                right = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 搜索到结果向两侧扩展</span><br>        <span class="hljs-keyword">while</span>(k--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(right &gt;= n || left &gt;= <span class="hljs-number">0</span> &amp;&amp; Math.abs(arr[left]-x)&lt;=Math.abs(arr[right]-x))&#123;<br>                ans.add(<span class="hljs-number">0</span>,arr[left--]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans.add(arr[right++]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findClosestElements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 避免越界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - k;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 如果左边界点与x的差值 &gt; 右边界点与x的差值 —&gt; 向右侧靠近</span><br>            <span class="hljs-keyword">if</span>( x - arr[mid] &gt; arr[mid+k] - x)&#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] copyOfRange = Arrays.copyOfRange(arr, left, left+k);<br>        <span class="hljs-keyword">return</span> Arrays.stream(copyOfRange).boxed().collect(Collectors.toList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找两个正序数组的中位数-（耻辱）-字节hard"><a href="#寻找两个正序数组的中位数-（耻辱）-字节hard" class="headerlink" title="寻找两个正序数组的中位数 （耻辱）  [字节hard]"></a>寻找两个正序数组的中位数 （耻辱）  [字节hard]</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</p><p>示例一</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：寻找算法+时间复杂度为<code>O(log(m+n))</code>&#x3D;二分法</p><p>那么怎么二分呢？</p><p>当m+n是奇数时，中位数就是中间的数 。 当 m+n是偶数时，中位数就是中间两个数的均值。</p><p>那么可以求两个有序数组的第 <code>(m+n+1) / 2</code>个数以及第 <code>(m+n+2)/2</code> 个数之和除二，如果长度是奇数则两个的值一样，如果长度是偶数就是中间两个数的均值。</p><p>问题转换为在两个有序数组里求第k个位数。（升序的话就是求第k小的数）</p><p>那怎么求的？这就是二分法的应用之处，我们先求各个数组的第k&#x2F;2个数，如果<code>nums1[k/2] == nums2[k/2]</code>那么第k个数就是二者任选其一。如果 <code>nums1[k/2] &lt; nums2[k/2]</code>那么就淘汰<code>nums1</code> 的前k&#x2F;2个数（此时转换成在两个有序数组（规模减去k&#x2F;2)里找第k-k&#x2F;2个数）。如果 <code>nums1[k/2] &gt; nums2[k/2]</code>那么就淘汰<code>nums2</code>的前k&#x2F;2个数。如果数组不存在k&#x2F;2个数那么，就赋予最大值</p><p>赋予最大值的意思只是说如果第一个数组的K&#x2F;2不存在，则说明这个数组的长度小于K&#x2F;2，那么另外一个数组的前K&#x2F;2个我们是肯定不要的。给你举个例子，加入第一个数组长度是2，第二个数组长度是12，则K为7，K&#x2F;2为3，因为第一个数组长度小于3，则无法判断第k位数是否在其中，而第二个数组的前3个肯定不是第k位数！故当K&#x2F;2不存在时，将其置为整数型最大值，这样就可以继续下一次循环。</p><p>二分的想法容易想到，但是细节却很难把握。</p><p>用i，j来表示<code>nums1,nums2</code>查找的起始位置，如果起始位置大于数组的长度，表示该数组所有数字都被淘汰，故返回另一个数组的起始位置加k位。</p><p>如果当k等于1时，就返回两个数组起始位置的最小值即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, left)+findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, right))/<span class="hljs-number">2.0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= nums1.length)<br>            <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (j &gt;= nums2.length)<br>            <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">midVal1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">midVal2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (midVal1 &lt; midVal2) &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums1, i + k / <span class="hljs-number">2</span>, nums2, j, k - k / <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变题：求两个正序数组的第K大的数</strong></p><p>已知道如何求第t位数，那么k和t 的关系有：<code>k+t = len1 + len2 + 1</code></p><p><strong>故求第k大的数等价于求第<code>len1 + len2 + 1 - k</code>位数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthBig</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums1.length + nums2.length + <span class="hljs-number">1</span> - k;<br>        <span class="hljs-keyword">return</span> findKth(nums1, <span class="hljs-number">0</span>, nums2, <span class="hljs-number">0</span>, t);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <br>        <span class="hljs-keyword">if</span> (i &gt;= nums1.length)<br>            <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (j &gt;= nums2.length)<br>            <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">midVal1</span> <span class="hljs-operator">=</span> (i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">midVal2</span> <span class="hljs-operator">=</span> (j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] : Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (midVal1 &lt; midVal2) &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums1, i + k / <span class="hljs-number">2</span>, nums2, j, k - k / <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="hljs-number">2</span>, k - k / <span class="hljs-number">2</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有序矩阵中第-K-小的元素-字节medium"><a href="#有序矩阵中第-K-小的元素-字节medium" class="headerlink" title="有序矩阵中第 K 小的元素 [字节medium]"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">有序矩阵中第 K 小的元素</a> [字节medium]</h3><p>给你一个 n x n 矩阵 matrix ，其中<strong>每行和每列元素均按升序排序</strong>，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p><blockquote><p>思路：</p><p>二分查找，搜索区域为：<code>[matrix[0][0],matrix[row-1][col-1]]</code>。查看中间值是否是第k小的数，如果小于中间值的数大于等于k，则让右边界缩小，否则让左边界缩小</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) /<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(checkt(matrix,mid) &lt; k)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkt</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix , <span class="hljs-type">int</span> mid)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; col)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &lt;= mid)&#123;<br>                <span class="hljs-comment">// 加一列的值</span><br>                count += i+<span class="hljs-number">1</span>;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻找重复数Ⅱ（耻辱）-字节medium"><a href="#寻找重复数Ⅱ（耻辱）-字节medium" class="headerlink" title="寻找重复数Ⅱ（耻辱）  [字节medium]"></a>寻找重复数Ⅱ（耻辱）  [字节medium]</h3><p>给定一个包含 <code>n + 1 </code>个整数的数组 <code>nums </code>，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设<code>nums</code><strong>只有 一个重复</strong>的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组<code> nums</code> 且只用<strong>常量级 O(1)</strong> 的额外空间。</p><blockquote><p>思路：</p><p>二分查找：问题其实是具有二义性的：因为数字都在[1,n]内，那么对于中间数mid，如果小于等于mid的数大于mid这个值，那么重复的区间肯定在[1~mid]内，否则就在[mid+1,n]之间。故二分查找是可以使用的</p><p>时间复杂度：O(n log(n))</p><p>空间复杂度：O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums)&#123;<br>                <span class="hljs-keyword">if</span>(n  &lt;= mid)&#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt &gt; mid)&#123;<br>                right = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>如果要求时间复杂度为O(N)该如何解决呢</p><p>其实应该使用快慢指针——因为有重复元素，相当于环（类比链表，即数组下标指向下标对应的值如[1,4,6,6,5,2,3] &#x3D; 0-&gt;1-&gt;4-&gt;6-&gt;3-&gt;6 ,这样就有环了，可以用环行链表那道题的方法来解决就是快慢指针）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">快慢指针思想, fast 和 slow 是指针, nums<span class="hljs-selector-attr">[slow]</span> 表示取指针对应的元素<br>注意 nums 数组中的数字都是在 <span class="hljs-number">1</span> 到 n 之间的(在数组中进行游走不会越界),<br>因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素, <br>即按照寻找链表环入口的思路来做<br></code></pre></td></tr></table></figure></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            fast = nums[nums[fast]];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(slow == fast) &#123;<br>                slow = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>                    fast = nums[fast];<br>                    slow = nums[slow];<br>                &#125;<br>                <span class="hljs-keyword">return</span> nums[slow];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找出第k小的距离对"><a href="#找出第k小的距离对" class="headerlink" title="找出第k小的距离对"></a>找出第k小的距离对</h3><p>数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 k ，数对由 <code>nums[i] 和 nums[j] </code>组成且满足 0 &lt;&#x3D; i &lt; j &lt; <code>nums.length</code> 。返回 所有数对距离中 第 k 小的数对距离。</p><p>提示：</p><ul><li><p>n &#x3D;&#x3D; <code>nums.length</code></p></li><li><p>2 &lt;&#x3D; n &lt;&#x3D; <code>1e4</code></p></li><li><p>0 &lt;&#x3D; <code>nums[i] </code>&lt;&#x3D; <code>1e6</code></p></li><li><p>1 &lt;&#x3D; k &lt;&#x3D; n * (n - 1) &#x2F; 2</p></li></ul><p>示例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br>解释：数对和对应的距离如下：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-number">2</span><br>距离第 <span class="hljs-number">1</span> 小的数对是 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) ，距离为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>二分法：左部和右部分别是数值的大小，即 left &#x3D; 0 , right &#x3D; max(<code>nums</code>)这里可以直接取<code>1e6</code></p><p>选出中值，然后去数组中求这个中值是第几小的距离对，如果大于k则修改右部，如果小于等于k则修改左部。</p><p>关键是如何快速地求这个中值是第几小的距离对</p><p>用两个变量i，j去遍历数组中的距离对，当<code>nums[j]-nums[i]&gt;mid</code>时，就不满足小于中值</p><p>此时小于mid的距离对有：<strong>j-i-1</strong>——怎么来的呢? [i,j-1]内的距离对都是满足小于mid的，那么由于i固定，其实这个区间的长度就是距离对的数目。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestDistancePair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e6</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(check(nums,mid) &lt; k)&#123;<br>                l = mid+ <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> mid)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= mid)&#123;<br>                j++;<br>            &#125;<br>            x+=j-i-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a><a href="https://leetcode.cn/problems/koko-eating-bananas/description/">爱吃香蕉的珂珂</a></h3><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p><p>提示：</p><ul><li><code>1 &lt;= piles.length &lt;= 1e4 </code></li><li><code>piles.length &lt;= h &lt;= 1e9</code></li><li><code>1 &lt;= piles[i] &lt;= 1e9</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>类似的题目有<span class="hljs-number">1014</span>,<span class="hljs-number">774</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：piles = [<span class="hljs-number">3,6,7,11</span>], h = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>二分查找</p><p>查找到不是piles[]数组，而是每小时吃k根的值域即<code>[1,1e9]</code></p><p>因为：</p><ul><li>如果每小时吃k根，吃完这堆香蕉需要 x个小时，如果x &lt;&#x3D; h那么这个速度就是算快的。修改右部值域，减小吃香蕉的速度</li><li>如果x &gt; h那么这个速度就是慢的，修改左部值域，增加吃香蕉的速度。</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(check(piles,mid,h)) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> h)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p : piles) ans += Math.ceil(p*<span class="hljs-number">1.0</span> / k);<br>        <span class="hljs-keyword">return</span> ans &lt;= h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a>分割数组的最大值</h3><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p><p>设计一个算法使得这 <code>m</code> 个<strong>子数组</strong>各自和的最大值最小。</p><p> 示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[7,2,5,10,8]</span>, m = 2<br>输出：18<br>解释：<br>一共有四种方法将 nums 分割为 2 个子数组。 <br>其中最好的方式是将其分为 <span class="hljs-comment">[7,2,5]</span> 和 <span class="hljs-comment">[10,8]</span> 。<br>因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>二分法：分的是数组和的最大值</p><p>左部边界值为<code>max(nums)</code>右部为<code>sum(nums)</code>。</p><p>贪心地模拟分割的过程，从前到后遍历数组，用  <code>sum</code> 表示当前分割子数组的和，<code>cnt</code> 表示已经分割出的子数组的数量（包括当前子数组），那么每当 <code>sum </code>加上当前值超过了 mid，意味着需要进行分割数组了，我们就把当前取的值作为新的一段分割子数组的开头，并将<code>&#123;cnt&#125;</code> 加 1。遍历结束后验证是否<code>cnt</code> 不超过 m。</p><p>计算数组和 的最大值不大于mid对应的子数组个数 <code>cnt</code><br>如果 <code>cnt&gt;m</code>，说明划分的子数组多了，即我们找到的 mid 偏小，故 l&#x3D;mid+1<br>否则，说明划分的子数组少了，即 mid 偏大(或者正好就是目标值)，故 h&#x3D;mid.</p><p>作者：Nick_kn<br>链接：<a href="https://leetcode.cn/leetbook/read/binary-search/xegsph/?discussion=BKiby9">https://leetcode.cn/leetbook/read/binary-search/xegsph/?discussion=BKiby9</a></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>            l = l &gt; i ? l:i;<br>            r+=i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>                sum += i;<br>                <span class="hljs-keyword">if</span>(sum &gt; mid)&#123;<br>                    cnt++;<br>                    sum = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt &lt; m)&#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a></h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><p>思路：</p><blockquote><p>和子数组相关的题目，主要有两种思路： **前缀和 ** 以及 <strong>滑动窗口双指针</strong> </p><p>这道题二者都可以。</p><p>先给出 <strong>前缀和</strong>这个思路的解法。</p><p>首先数组中的元素都是正数，那么其前缀和数组就是一个递增的数组。</p><p>以<code>nums[i]</code>对应的前缀和数组是<code>sum[i+1]</code>，我们把<code>nums[i]</code>视作子数组的右端点。</p><p>问题就转换为：</p><p>在前缀和数组下标[0,,,i]之间找到一个值d，使得d &lt;&#x3D; s - t的最大下标。作为子数组的左端点。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= n; i++)&#123;<br>            sum[i] = sum[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sum[i] , d = s-target;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i;<br>             <span class="hljs-comment">// 用于记录小于等于s-t的最大下标</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(sum[mid] &lt;= d)&#123;<br>                    idx = mid;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(idx != -<span class="hljs-number">1</span> &amp;&amp; sum[idx] &lt;= d ) ans = Math.min(ans,i-idx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == n+<span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br><span class="hljs-comment">// 双指针做法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doublePointer</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; right &lt; n; right++)&#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>                res = Math.min(res,right-left+<span class="hljs-number">1</span>);<br>                sum -= nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面用了一个额外的变量来记录小于等于s-t的最大下标，其实还可以这样做：之间用left来记录满足条件的最大下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = i;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> ;<br><span class="hljs-keyword">if</span>(sum[mid] &lt;= d)&#123;<br>l = mid;<br>&#125; <br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>; <br>&#125;<br><span class="hljs-keyword">if</span>(sum[l] &lt;= d) ans = Math.min(ans,i-l);<br></code></pre></td></tr></table></figure><h3 id="和至少为-K-的最短子数组"><a href="#和至少为-K-的最短子数组" class="headerlink" title="和至少为 K 的最短子数组"></a><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a></h3><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p><p>子数组 是数组中 连续 的一部分。</p><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,-1,2], k = 3</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><blockquote><p>这道题和上一题不同的点就是，<code>nums</code>中的元素有负数，这样一来，滑动窗口和前缀和就不是单调递增的。所以一般的滑动窗口就无法使用。</p><p>破局的关键还是：前缀和。因为问题就是找<code>preSum[j]-preSum[i] &gt;=k</code>且<code>j-i</code>最小。</p><p>所以朴素的解法就是求前缀和数组，然后暴力遍历<code>j和i</code>来求得答案</p></blockquote><p>暴力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> A.length + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length + <span class="hljs-number">1</span>];<br>        preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + A[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; A.length + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((preSum[j] - preSum[i]) &gt;= K) &#123;<br>                    <span class="hljs-keyword">if</span> ((j - i) &lt; minLen) &#123;<br>                        minLen = j - i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLen == A.length + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : minLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面得暴力来优化。</p><ul><li>如果<code>preSum[x2] &lt;= preSum[x1]且x1 &lt; x2</code>以为着<code>[x1,x2]</code>区间和为负数或者为0，那么如果<code>preSum[xn] - preSum[x1] &gt;= k</code>那么一定会有<code>preSum[xn]-preSum[x2]&gt;=k</code>所以我们可以抛弃掉<code>x2之前的值</code>。</li><li>如果<code>preSum[x2]-preSum[x1] &gt;= k</code>时，<code>preSum[x1]</code>其实是可以抛弃的，因为<code>x1到x2</code>已经满足条件了，如果再往后找，则长度肯定大于<code>x2-x1</code>。</li></ul><p>由上述两个优化点，我们可以构建一个单调增队列。</p><ul><li>队尾如果大于等于当前遍历的前缀和，则弹出队尾。</li><li>当前遍历如果和队头能够满足条件，则弹出队头。更新长度。</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> A.length + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[A.length + <span class="hljs-number">1</span>];<br>        preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + (<span class="hljs-type">long</span>)A[i];<br>        &#125;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i  &lt; preSum.length; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; preSum[i] &lt;= preSum[deque.peekLast()])&#123;<br>                deque.pollLast();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(deque.size() != <span class="hljs-number">0</span> &amp;&amp; preSum[i] - preSum[deque.peekFirst()] &gt;=k)&#123;<br>                minLen = Math.min(minLen, i - deque.pollFirst());<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLen == A.length + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : minLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的连续子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><blockquote><p>子数组问题，联想到前缀和。</p><p>前缀和的思想就是，我们当前的前缀和preSum，需要找到之前有多少个前缀和等于preSum-k。</p><p>这是因为满足<code>preSum - (preSum-k) = k </code>才是我们所希望的。</p><p>对于一开始的情况，下标 0 之前没有元素，可以认为前缀和为 0，个数为 1 个，因此 <code>preSumFreq.put(0, 1);</code>，这一点是必要且合理的。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums )&#123;<br>            preSum += n;<br>            <span class="hljs-keyword">if</span>(map.containsKey(preSum-k))&#123;<br>                count += map.get(preSum-k);<br>            &#125;<br>            map.put(preSum,map.getOrDefault(preSum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找和最小的-K-对数字"><a href="#查找和最小的-K-对数字" class="headerlink" title="查找和最小的 K 对数字"></a><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/">查找和最小的 K 对数字</a></h3><p>给定两个以 <strong>升序排列</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code> , 以及一个整数 <code>k</code> 。</p><p>定义一对值 <code>(u,v)</code>，其中第一个元素来自 <code>nums1</code>，第二个元素来自 <code>nums2</code> 。</p><p>请找到和最小的 <code>k</code> 个数对 <code>(u1,v1)</code>, <code> (u2,v2)</code> …  <code>(uk,vk)</code> 。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums1 = <span class="hljs-comment">[1,7,11]</span>, nums2 = <span class="hljs-comment">[2,4,6]</span>, k = 3<br>输出: <span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[1,6]</span><br>解释: 返回序列中的前 3 对数：<br>     <span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,2]</span>,<span class="hljs-comment">[7,4]</span>,<span class="hljs-comment">[11,2]</span>,<span class="hljs-comment">[7,6]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[11,6]</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>使用堆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=373 lang=java</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [373] 查找和最小的 K 对数字</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> nums2.length;<br>        PriorityQueue&lt;List&lt;Integer&gt;&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>            (o1, o2) -&gt; (o2.get(<span class="hljs-number">0</span>)+o2.get(<span class="hljs-number">1</span>)) - (o1.get(<span class="hljs-number">0</span>)+o1.get(<span class="hljs-number">1</span>))<br>            );<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len2; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums1[i] + nums2[j];<br>                List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                temp.add(nums1[i]);<br>                temp.add(nums2[j]);<br>                <span class="hljs-keyword">if</span>(heap.size() &lt; k) heap.add(temp);<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> heap.peek().get(<span class="hljs-number">0</span>)+heap.peek().get(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span>(s &gt; sum)&#123;<br>                        heap.poll();<br>                        heap.add(temp);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(heap);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>多路归并：</p><p>我们再来分析一下时间复杂度，假设 n &#x3D; <code>nums1.length</code>, m &#x3D; <code>num2.length</code></p><p>按照上图的方法构造有序链表的话，每次需要从 n 个元素中找出最小的元素，需要找 k 次，所以时间复杂度为 O(k log(n)</p><p>所以为了更优的时间复杂度，尽量让<code>nums1</code>长度更短；如果<code>nums1</code>长度更长，我们就交换两个数组的位置</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标志是否交换了位置 true : 未交换；false : 交换了</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length, m = nums2.length;<br>    <span class="hljs-comment">// 判断是否需要交换顺序</span><br>    <span class="hljs-keyword">if</span> (n &gt; m &amp;&amp; !(flag = <span class="hljs-literal">false</span>)) <span class="hljs-keyword">return</span> kSmallestPairs(nums2, nums1, k);<br>    <span class="hljs-comment">// 注意：队列中存储的只是下标</span><br>    <span class="hljs-comment">// 按照「两数和」递增排列</span><br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; nums1[a[<span class="hljs-number">0</span>]] + nums2[a[<span class="hljs-number">1</span>]] - nums1[b[<span class="hljs-number">0</span>]] - nums2[b[<span class="hljs-number">1</span>]]);<br>    <span class="hljs-comment">// 加入头节点</span><br>    <span class="hljs-comment">// 这里有一个技巧：如果 k &lt; n，那么一开始只需要往队列中添加前 k 个元素即可</span><br>    <span class="hljs-comment">// 后面的 n - k 个元素肯定比前面 k 个元素大，所以加入没有意义</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(n, k); i++) q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (ans.size() &lt; k &amp;&amp; !q.isEmpty()) &#123;<br>        <span class="hljs-comment">// 弹出队顶元素，即最小元素</span><br>        <span class="hljs-type">int</span>[] cur = q.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>], b = cur[<span class="hljs-number">1</span>];<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;()&#123;&#123;<br>            add(flag ? nums1[a] : nums2[b]);<br>            add(flag ? nums2[b] : nums1[a]);<br>        &#125;&#125;);<br>        <span class="hljs-comment">// 如果 b + 1 &lt; m 表示该条链条后面还有元素，可以继续加入队列中</span><br>        <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> &lt; m) q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a, b + <span class="hljs-number">1</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>二分：</p><p>首先在找到第k大的数值对。这个可以使用二分查找法来查找，因为这个具有二义性：点对和小于x的数量少于k个，点对和数量大于等于x的大于等于k个。</p><p>然后把小于第k大的点对和加入答案中。</p><p>然后再把点对和等于第k大的数值对加入答案：</p><ul><li>遍历第一个数组，然后二分查找<code>sum-nums1[i]</code>的第一次和最后一次出现的位置。</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums1, nums2;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] n1, <span class="hljs-type">int</span>[] n2, <span class="hljs-type">int</span> k)</span> &#123;<br>        nums1 = n1; nums2 = n2;<br>        n = nums1.length; m = nums2.length;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums1[<span class="hljs-number">0</span>] + nums2[<span class="hljs-number">0</span>], r = nums1[n - <span class="hljs-number">1</span>] + nums2[m - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">0L</span> + l + r &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (check(mid, k)) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i] + nums2[j] &lt; x) &#123;<br>                    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    temp.add(nums1[i]); temp.add(nums2[j]);<br>                    ans.add(temp);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; ans.size() &lt; k; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums1[i], b = x - a;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, d = -<span class="hljs-number">1</span>;<br>            l = <span class="hljs-number">0</span>; r = m - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 找到第一个出现的值</span><br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">0L</span> + l + r &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (nums2[mid] &gt;= b) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums2[r] != b) <span class="hljs-keyword">continue</span>;<br>            c = r;<br>            l = <span class="hljs-number">0</span>; r = m - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//找到最后一个出现的值</span><br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">0L</span> + l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (nums2[mid] &lt;= b) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            d = r;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> c; p &lt;= d &amp;&amp; ans.size() &lt; k; p++) &#123;<br>                List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                temp.add(a); temp.add(b);<br>                ans.add(temp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; ans &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m &amp;&amp; ans &lt; k; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i] + nums2[j] &lt;= x) ans++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &gt;= k;<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-k-pairs-with-smallest-sums/solution/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/</span><br></code></pre></td></tr></table></figure><h3 id="绝对差值和"><a href="#绝对差值和" class="headerlink" title="绝对差值和"></a><a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/description/">绝对差值和</a></h3><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p><p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><code>|x|</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：<br>- 将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者<br>- 将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |<span class="hljs-string">1-2</span>|<span class="hljs-string"> + (</span>|<span class="hljs-string">1-3</span>|<span class="hljs-string"> 或者 </span>|<span class="hljs-string">5-3</span>|<span class="hljs-string">) + </span>|<span class="hljs-string">5-5</span>|<span class="hljs-string"> = 3</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>处理前，先把<code>nums1</code>拷贝并排序为sort</p><p>然后 在遍历 <code>nums1</code>和 <code>nums2</code> 计算总的差值 <code>sum</code>时，通过对 <code>sort</code> 进行二分查找，找到最合适替换 <code>nums1[i]</code> 的值。即最接近当前的<code>nums2[i]</code>的值。</p><p>具体的，当我们处理到第 i 位时，假设该位的原差值为 x &#x3D; abs(<code>nums1[i] - nums2[i]</code>)然后从 <code>sort</code> 数组中通过二分找到最接近 <code>nums2[i] </code>的值，计算一个新的差值 <code>nd</code>（注意要检查分割点与分割点的下一位），如果满足 <code>nd &lt; x</code> 说明存在一个替换方案使得差值变小，我们使用变量 <code>var</code>记下来这个替换方案所带来的变化，并不断更新 <code>var</code>。因为只允许至多替换一个。所以记录最大的变化量即可。</p></blockquote><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-comment">//[1818] 绝对差值和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAbsoluteSumDiff</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span>[] sort = nums1.clone();<br>        Arrays.sort(sort);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums1[i], b = nums2[i];<br>            <span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Math.abs(a-b);<br>            sum += x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n-<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 这个是找到最接近nums2[i]的上界</span><br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r-l) / <span class="hljs-number">2</span>  ;<br>                <span class="hljs-keyword">if</span>(sort[mid] &lt; b)&#123;<br>                    l = mid + <span class="hljs-number">1</span>  ;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid  ;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nd</span> <span class="hljs-operator">=</span> Math.abs(sort[l] - b);<br>            <span class="hljs-comment">// 需要比较下一个是否一样</span><br>            <span class="hljs-keyword">if</span>(l - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> ) nd = Math.min(nd, Math.abs(sort[l-<span class="hljs-number">1</span>]-b));<br>            <span class="hljs-keyword">if</span>(nd &lt; x) <span class="hljs-keyword">var</span> = Math.max(<span class="hljs-keyword">var</span>, x-nd);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)((sum - <span class="hljs-keyword">var</span>) % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第-k-个缺失的正整数"><a href="#第-k-个缺失的正整数" class="headerlink" title="第 k 个缺失的正整数"></a><a href="https://leetcode.cn/problems/kth-missing-positive-number/description/">第 k 个缺失的正整数</a></h3><p>给你一个 <strong>严格升序排列</strong> 的正整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p><p>请你找到这个数组里第 <code>k</code> 个缺失的正整数。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">2,3,4,7</span>,<span class="hljs-number">11</span>], k = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">9</span><br>解释：缺失的正整数包括 [<span class="hljs-number">1,5,6,8</span>,<span class="hljs-number">9,10,12,13</span>,...] 。第 <span class="hljs-number">5</span> 个缺失的正整数为 <span class="hljs-number">9</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>按照迭代的思路，我们每遍历到数组的一个元素，就能知道在这个元素之前有多少个缺失元素，计算方式如下：</p><p>设：arr &#x3D; [2,3,4,7,11], k &#x3D; 5</p><p>我们可以利用数组下标来得到该位置之前缺失的元素数量，例如：</p><p>i &#x3D; 0，此时数组元素arr[i] &#x3D; 2，在0位置上，不缺失的情况下，对应的元素应该是1，所以缺失个数为arr[i] - i - 1 &#x3D; 1,因为数组下标是从0开始的，而元素是从1开始的，所以计算个数的时候，除了减掉下标值之外，还需要再减1.</p><p>按照这个方式，能计算出该数组的每个元素对应的缺失元素个数</p><p>我们要求的是找到缺失的第k个整数，观察每个元素对应的缺失个数，它们所构成的序列是一个非严格递增的序列，也就是说，在这个序列中，我们能够通过二分查找，找到k所对应的位置，有了这个位置，我们就能通过对应的元素找到缺失的第k个整数。</p><p>举例来说，如果要找到k &#x3D; 5，第5个缺失的元素，那么我们需要从一个确定的数向后或向前推算：</p><ul><li>对于2,3,4来说，它们之前缺少1个元素，所以我们不考虑这些元素。</li><li>对于7来说，它之前缺少3个元素，那么从它开始往后推2个元素，就有可能是缺失的第5个元素。前提是它后面的元素缺失数量要大于k &#x3D; 5</li><li>对于11来说，它之前缺少6个元素，我们要找的第5个元素，一定是在它之前缺失的，那从它开始往前推2个元素（第6个，第5个），就是我们要找的缺失的第5个元素。</li><li>根据这种分析，我们就可以在这个缺失数量的序列上进行二分查找，确定一个区间[i,j]，满足lack[i] &lt; k &lt;&#x3D; lack[j]，则第k个缺失的数为k - (arr[i] - i - 1) + arr[i]，arr[i] - i - 1表示arr[i]位置缺少的元素个数，k - 缺失个数表示从arr[i]开始还缺少几个元素，再加上arr[i]，就是第k个缺失的元素</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 第一个数比缺失的数要大的话，直接返回k</span><br>        <span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>] &gt; k)&#123;<br>            <span class="hljs-keyword">return</span> k;<br>        &#125;<br>        <span class="hljs-comment">// 找到缺失数量大于k的最小的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = arr.length;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> mid &lt; arr.length ? arr[mid] : Integer.MAX_VALUE;<br>            <span class="hljs-keyword">if</span>(x - mid - <span class="hljs-number">1</span> &gt;= k)&#123;<br>                right = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第k个缺失的数 - （最小位置之前的那个数所缺失的个数） + 最小位置前面的那个数</span><br>        <span class="hljs-comment">// 5 - （7 - 3 - 1） + 7 = 第五个缺失的数 - 7前面有3个缺失的数 + 7</span><br>        <span class="hljs-keyword">return</span> k - (arr[left - <span class="hljs-number">1</span>] - (left - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) + arr[left - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br>作者：max-LFszNScOfE<br></code></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><blockquote><p>分治法的思路是这样的，其实也是分类讨论。</p><p>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p><p>第 1 部分：子区间 [left, mid]；<br>第 2 部分：子区间 [mid + 1, right]；<br>第 3 部分：包含子区间 [mid , mid + 1] 的子区间，即 nums[mid] 与 nums[mid + 1] 一定会被选取。<br>对这三个部分求最大值即可。</p><p>说明：考虑第 3 部分跨越两个区间的连续子数组的时候，由于 <code>nums[mid] 与 nums[mid + 1]</code> 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值，具体请见「参考代码 6」。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSubArraySum(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCrossingSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 一定会包含 nums[mid] 这个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span><br>        <span class="hljs-comment">// 走到最边界，看看最值是什么</span><br>        <span class="hljs-comment">// 计算以 mid 结尾的最大的子数组的和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mid; i &gt;= left; i--) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (sum &gt; leftSum) &#123;<br>                leftSum = sum;<br>            &#125;<br>        &#125;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span><br>        <span class="hljs-comment">// 计算以 mid+1 开始的最大的子数组的和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (sum &gt; rightSum) &#123;<br>                rightSum = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftSum + rightSum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> max3(maxSubArraySum(nums, left, mid),<br>                maxSubArraySum(nums, mid + <span class="hljs-number">1</span>, right),<br>                maxCrossingSum(nums, left, mid, right));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max3</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">int</span> num3)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(num1, Math.max(num2, num3));<br>    &#125;<br>&#125;<br><br>作者：liweiwei1419<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h3 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a><a href="https://leetcode.cn/problems/divide-two-integers/">两数相除</a></h3><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2</p><blockquote><p>由于题目限定了我们不能使用乘法、除法和 mod 运算符。</p><p>我们可以先实现一个「倍增乘法」，然后利用对于 x 除以 y，结果 x &#x2F; y 必然落在范围 [0, x] 的规律进行二分。</p><p>即二分查找<code>[0,x]</code>里的值mid，如果满足<code>mid*y&lt;=x</code>记录满足这个条件的最大值mid。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a, y = b;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNeg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> ((x &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) || (x &lt; <span class="hljs-number">0</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>)) isNeg = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x = -x;<br>        <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) y = -y;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = x;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (mul(mid, y) &lt;= x) &#123;<br>                l = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> isNeg ? -l : l;<br>        <span class="hljs-keyword">if</span> (ans &gt; Integer.MAX_VALUE || ans &lt; Integer.MIN_VALUE) <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>    <span class="hljs-comment">// 快速乘法</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ans += a;<br>            k &gt;&gt;= <span class="hljs-number">1</span>;<br>            a += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/divide-two-integers/solution/shua-chuan-lc-er-fen-bei-zeng-cheng-fa-j-m73b/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="递归-x2F-回溯"><a href="#递归-x2F-回溯" class="headerlink" title="递归&#x2F;回溯"></a>递归&#x2F;回溯</h2><p>经典的回溯模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//符合条件的结果集合</span><br>ans = [] <br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(路径，选择列表)</span> &#123;<br>    <span class="hljs-keyword">if</span> (满足结束条件) &#123;<br>        ans.add(路径);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择 : 选择列表) &#123;<br>        做选择<br>        backtracking(路径，选择列表)<br>        撤销选择<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="合并K个升序链表-字节hard"><a href="#合并K个升序链表-字节hard" class="headerlink" title="合并K个升序链表   [字节hard]"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并K个升序链表</a>   [字节hard]</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>归并排序：归并[l,mid] 和[mid, r] 所产生的有序链表</p></blockquote><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">if</span>( lists == <span class="hljs-literal">null</span> || lists.length &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<br>        <span class="hljs-keyword">return</span> mergeLists(lists,<span class="hljs-number">0</span>,lists.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeLists</span><span class="hljs-params">(ListNode[] list, <span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l == r)&#123;<br>            <span class="hljs-keyword">return</span> list[l];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> merge(mergeLists(list,l,mid),mergeLists(list,mid+<span class="hljs-number">1</span>,r));<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span> || l2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span>dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val)&#123;<br>                cur.next =l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span>)&#123;<br>            cur.next = l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">null</span>)&#123;<br>            cur.next = l1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优先队列——多路归并</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1.val &lt; o2.val) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.val == o2.val) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">for</span>(ListNode list : lists)&#123;<br>            <span class="hljs-keyword">if</span>(list != <span class="hljs-literal">null</span>)&#123;<br>                queue.add(list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            cur.next = queue.poll();<br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span>(cur.next != <span class="hljs-literal">null</span>) queue.add(cur.next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-个一组翻转链表-字节hard"><a href="#K-个一组翻转链表-字节hard" class="headerlink" title="K 个一组翻转链表    [字节hard]"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">K 个一组翻转链表  </a>  [字节hard]</h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><blockquote><p>递归</p><p>我们可以很轻松地写处翻转链表的程序</p><p>题目说是k个一组，那么就是翻转链表的while循环判断上需要进行修改，我们先遍历到第k+1个，作为尾部，然后进行翻转链表，while循环上原本是判断是否为null现在改为判断是否到达尾部。</p><p>然后再递归尾部之后的链表。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k ; i++)&#123;<br>            <span class="hljs-keyword">if</span>(tail == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            tail = tail.next;<br>        &#125;<br>        <span class="hljs-comment">// 翻转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != tail)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        head.next = reverseKGroup(tail,k);<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重排链表-字节medium"><a href="#重排链表-字节medium" class="headerlink" title="重排链表   [字节medium]"></a><a href="https://leetcode.cn/problems/reorder-list/description/">重排链表 </a>  [字节medium]</h3><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><blockquote><p>思路：</p><p>用线性表存储，因为线性表支持下标索引，遍历该表，重建链表即可</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            list.add(p);<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            list.get(i).next = list.get(j);<br>            i++;<br>            <span class="hljs-keyword">if</span>(i == j)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            list.get(j).next = list.get(i);<br>            j--;<br>        &#125;<br>        list.get(i).next = <span class="hljs-literal">null</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这道题其实是三道题的合集：</p><ol><li>寻找链表的中点</li><li>翻转链表</li><li>合并链表</li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> middleNode(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        l2 = reverseList(l2);<br>        merger(l1,l2);<br>    &#125;<br>    <span class="hljs-comment">// 中间点</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><span class="hljs-comment">// 翻转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><span class="hljs-comment">// 合并链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merger</span><span class="hljs-params">(ListNode l1, ListNode l2)</span>&#123;<br>        ListNode l1_temp ;<br>        ListNode l2_temp;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>)&#123;<br>            l1_temp = l1.next;<br>            l2_temp = l2.next;<br><br>            l1.next = l2;<br>            l1 = l1_temp;<br><br>            l2.next = l1;<br>            l2 = l2_temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表排序（归并排序）"><a href="#链表排序（归并排序）" class="headerlink" title="链表排序（归并排序）"></a>链表排序（归并排序）</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;     <br>        <span class="hljs-keyword">return</span> sort(head,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode head, ListNode tail)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.next == tail)&#123;<br>            head.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast!=tail)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span> (fast != tail) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> slow;<br>        <span class="hljs-keyword">return</span> mergerSort(sort(head,mid),sort(mid,tail));<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergerSort</span><span class="hljs-params">(ListNode l1, ListNode l2)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val)&#123;<br>                p.next = l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span>)&#123;<br>            p.next = l2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p.next = l1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速选择O-N"><a href="#快速选择O-N" class="headerlink" title="快速选择O(N)"></a>快速选择O(N)</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lomutoPartition(arr,left,right);<br>        <span class="hljs-keyword">if</span>(s == left + k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt; left + k - <span class="hljs-number">1</span>) quickSelect(arr,left,s-<span class="hljs-number">1</span>,k);<br>        <span class="hljs-keyword">else</span> quickSelect(arr,s+<span class="hljs-number">1</span>,right,left+k-<span class="hljs-number">1</span>-s);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(r - l  + <span class="hljs-number">1</span>) + l;<br>        swap(arr,i,l);<br>        <span class="hljs-keyword">return</span> lomutoPartition(arr,l,r);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lomutoPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> arr[left];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i] &lt;= p)&#123;<br>                s++;<br>                swap(arr,s,i);<br>            &#125;<br>        &#125;<br>        swap(arr,left,s);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组中的逆序对-字节hard"><a href="#数组中的逆序对-字节hard" class="headerlink" title="数组中的逆序对 [字节hard]"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a> [字节hard]</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p> <strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><blockquote><p>归并排序</p><p>归并排序如何计算逆序对呢，计算逆序对的过程其实就是在“并”的过程。</p><p>将数组分成左右两个有序的部分<code>L=nums[l,m],R=nums[m,r]</code></p><p>如果<code>R</code>数组第j位小于L数组第i位，那么就产生了逆序对，逆序对数是：<code>m-i+1</code>即<code>L</code>数组中剩余的数目。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] tmp;<span class="hljs-comment">// 只用一个辅助数组，否则会超时。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">return</span> MergeSort(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span>( l &gt;= r)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> MergeSort(nums,l,m)+MergeSort(nums,m+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l ; k &lt;= r; k++)&#123;<br>            tmp[k] = nums[k];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = m+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l; k &lt;= r; k++)&#123;<br>            <span class="hljs-keyword">if</span>(i == m+<span class="hljs-number">1</span>)&#123;<br>                nums[k] = tmp[j++];   <br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == r+<span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j])&#123;<br>                nums[k] = tmp[i++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums[k] = tmp[j++];<br>                res += (m - i + <span class="hljs-number">1</span>); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树中的最大路径和-字节hard"><a href="#二叉树中的最大路径和-字节hard" class="headerlink" title="二叉树中的最大路径和 [字节hard]"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a> [字节hard]</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="/leetcode_recod.assets/exx1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><blockquote><p>本题可以从任意的节点出发，到达任意节点，求这条路径的最大值。</p><p>其实我们可以把这个二叉树情况进行分解：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">a</span><br> / \<br><span class="hljs-selector-tag">b</span>   c<br></code></pre></td></tr></table></figure><p>路径和的情况有以下几种：</p><ol><li>a+b+c</li><li>a+b + a的父节点</li><li>a+c + a的父节点</li></ol><p>其中情况1是无法递归的，但是它可以是最大值的来源</p><p>情况2，3可以进行递归。选择2，3的最优方案返回。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        maxGain(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxGain</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取左子树和的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> Math.max(maxGain(root.left),<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 获取右子树和的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightSum</span> <span class="hljs-operator">=</span> Math.max(maxGain(root.right),<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.val + leftSum +rightSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> root.val + Math.max(leftSum, rightSum);<br>        maxSum = Math.max(maxSum,Math.max(ret,temp));<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的直径-字节easy"><a href="#二叉树的直径-字节easy" class="headerlink" title="二叉树的直径 [字节easy]"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a> [字节easy]</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><pre><code class="hljs">      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><blockquote><p>任意一条路径，可以看作是从某个起点出发，将其左儿子和右儿子向下遍历的路径拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 <code>L</code> （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 <code>R </code>（即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 <code>L+R+1 </code>。</p><p>所以我们可以定义一个深度优先搜索函数：dfs(root)</p><p>函数返回以root为根的子树的深度<code>max(left, right)+1</code>。</p><p>然后经过root的直径就是：L+R+1</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        ret = Math.max(left+right+<span class="hljs-number">1</span>,ret);<br>        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/">全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p> <strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>回溯：</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; temp)</span>&#123;<br>        <span class="hljs-keyword">if</span>(temp.size() == nums.length)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(temp));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!temp.contains(nums[i]))&#123;<br>                temp.add(nums[i]);<br>                dfs(nums,temp);<br>                temp.pollLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复原-IP-地址-字节medium"><a href="#复原-IP-地址-字节medium" class="headerlink" title="复原 IP 地址 [字节medium]"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">复原 IP 地址</a> [字节medium]</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#x40;&#49;&#46;&#49;">&#x31;&#x39;&#x32;&#x2e;&#x31;&#54;&#x38;&#x40;&#49;&#46;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>给定字符串，要求 <strong>所有可能的IP地址</strong>，很明显只能使用回溯。</p><p>回溯函数该怎么写呢？</p><p>我们可以定义<code>dfs(String s, int startIndex, int level)</code> 来求解。</p><p><code>s</code>表示题目所给的IP字符串。</p><p><code>startIndex</code>表示这一段ip地址的起始下标。</p><p><code>level</code>表示这是第几段ip地址。(o~3)当level &#x3D; 4 时表示已经找到一个可能的ip地址了。</p><p>详细见代码：</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        dfs(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidId</span><span class="hljs-params">(String s )</span>&#123;<br>        <span class="hljs-comment">// 不能有前导零</span><br>        <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//长度大于3就返回</span><br>        <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//ip值大于255就返回</span><br>        <span class="hljs-keyword">if</span>(Integer.parseInt(s) &gt; <span class="hljs-number">255</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> level)</span>&#123;<br>        <span class="hljs-keyword">if</span>(level == <span class="hljs-number">4</span>)&#123;<br>            ans.add(String.join(<span class="hljs-string">&quot;.&quot;</span>,temp));<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-comment">// 查看剩余字符串能不能够凑成ip地址。如果剩余字符串长度过大，则无法凑成。</span><br>            <span class="hljs-keyword">if</span>((s.length()-i-<span class="hljs-number">1</span>) &gt; <span class="hljs-number">3</span>*(<span class="hljs-number">3</span>-level))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(startIndex, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(!isValidId(sub))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            temp.add(sub);<br>            dfs(s,i+<span class="hljs-number">1</span>,level+<span class="hljs-number">1</span>);<br>            temp.remove(temp.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词搜索-字节medium"><a href="#单词搜索-字节medium" class="headerlink" title="单词搜索 [字节medium]"></a><a href="https://leetcode.cn/problems/word-search/">单词搜索</a> [字节medium]</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br><br></code></pre></td></tr></table></figure><blockquote><p>回溯：</p><p>注意访问过的单元格要置为已访问。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">find</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m ; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                dfs(board,word,i,j,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span>(find)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> find;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j,<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(i &lt;<span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j&gt;= n || board[i][j] != word.charAt(index))&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == word.length() - <span class="hljs-number">1</span>)&#123;<br>            find = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(index);<br>        board[i][j] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        dfs(board,word,i+<span class="hljs-number">1</span>,j,index+<span class="hljs-number">1</span>);<br>        dfs(board,word,i-<span class="hljs-number">1</span>,j,index+<span class="hljs-number">1</span>);<br>        dfs(board,word,i,j+<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>);<br>        dfs(board,word,i,j-<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>);<br>        board[i][j] = c;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode.cn/problems/subsets/">子集</a></h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>回溯：子集其实是一种组合，因为[1,2]和[2,1]是一样的。所以for循环要从startIndex开始。如果是求排列的话，for循环就要从0开始</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(temp));<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex ;i &lt; nums.length; i++)&#123;<br>            temp.add(nums[i]);<br>            dfs(nums,i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 从i+1开始，元素不重复取</span><br>            temp.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">子集 II</a></h3><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span>&#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(temp));<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.length)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex ;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// 去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; startIndex &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            temp.add(nums[i]);<br>            dfs(nums,i+<span class="hljs-number">1</span>);<br>            temp.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">N 皇后</a></h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><blockquote><p>思路：</p><p>这是经典的回溯算法题。</p><p>我们先初始化这个棋盘<code>board[][]为&#39;.&#39;</code>。</p><p>我们可以先确定一个维度，比如行，然后再去遍历列。</p><p>所以我们的回溯算法是根据行来确定每一层的皇后位置是放置在哪一列。</p><p>我们需要对放置的位置进行判断，是否合法：</p><ul><li>因为我们是按行来确定回溯的层次深度，所以我们人为确定一行只会有一个皇后。所以不用对同一行上判断是否有皇后存在。</li><li>遍历当前列，确定这一行之前的这个列的位置上没有皇后。 </li><li>确定当前位置的左上角对角线没有皇后</li><li>确定当前位置的右上角对角线没有皇后。</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[][] board;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;board.length; ++i) &#123;<br>            Arrays.fill(board[i], <span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>,n,board);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row , <span class="hljs-type">int</span> n ,<span class="hljs-type">char</span>[][]board)</span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<br>            ans.add(array2List(board));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!check(n,row,i,board))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            board[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            dfs(row+<span class="hljs-number">1</span>,n,board);<br>            board[row][i] =<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>&#123;<br>        List&lt;String&gt; list= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>            list.add(String.valueOf(board[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> n , <span class="hljs-type">int</span> row , <span class="hljs-type">int</span> col ,<span class="hljs-type">char</span>[][]board)</span>&#123;<br>        <span class="hljs-comment">// 列位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">// 左上角</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col -<span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> ; i--,j--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">// 右上角</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>, j = col+<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--,j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵中的最长递增路径-字节hard"><a href="#矩阵中的最长递增路径-字节hard" class="headerlink" title="矩阵中的最长递增路径 [字节hard]"></a><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">矩阵中的最长递增路径</a> [字节hard]</h3><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p><strong>示例 1：</strong></p><p><img src="/leetcode_recod.assets/grid1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[9,9,4]</span>,<span class="hljs-comment">[6,6,8]</span>,<span class="hljs-comment">[2,1,1]</span>]</span><br>输出：4 <br>解释：最长递增路径为 <span class="hljs-comment">[1, 2, 6, 9]</span>。<br></code></pre></td></tr></table></figure><blockquote><p>思路一：</p><p>正常的回溯，暴搜。会TLE</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>                dfs(matrix,i,j,<span class="hljs-number">1</span>, vis);<br>                vis[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix,<span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> path,<span class="hljs-type">boolean</span>[][] vis)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        ans = Math.max(path,ans);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir : dirs)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nx &lt; <span class="hljs-number">0</span> || ny &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &gt;= n || vis[nx][ny] || matrix[i][j] &gt;= matrix[nx][ny])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            vis[nx][ny] = <span class="hljs-literal">true</span>;<br>            dfs(matrix,nx,ny,path+<span class="hljs-number">1</span>,vis);<br>            vis[nx][ny] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路二：记忆化搜索</p><p>用<code>memo[i][j]</code>来存储以i，j为起点的最长递增路径长度。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                ans = Math.max(ans,dfs(matrix,i,j,memo));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix,<span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] memo)</span>&#123;<br>        <span class="hljs-keyword">if</span>(memo[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> memo[i][j];<br>        &#125;<br>        ++memo[i][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir : dirs)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; matrix[i][j] &lt; matrix[nx][ny])&#123;<br>                memo[i][j] = Math.max(memo[i][j],dfs(matrix,nx,ny,memo)+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词拆分-II"><a href="#单词拆分-II" class="headerlink" title="单词拆分 II"></a><a href="https://leetcode.cn/problems/word-break-ii/">单词拆分 II</a></h3><p>给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。</p><p>注意：词典中的同一个单词可能在分段中被重复使用多次。</p><p><strong>示例1</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入:s = <span class="hljs-string">&quot;catsanddog&quot;</span>, wordDict = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;cats&quot;</span>,<span class="hljs-string">&quot;and&quot;</span>,<span class="hljs-string">&quot;sand&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>]<br>输出:[<span class="hljs-string">&quot;cats and dog&quot;</span>,<span class="hljs-string">&quot;cat sand dog&quot;</span>]<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>       <br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        dfs(s,<span class="hljs-number">0</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;(), set);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> idx , LinkedList&lt;String&gt; path, Set&lt;String&gt; set)</span>&#123;<br>        <span class="hljs-keyword">if</span>(idx == s.length())&#123;<br>            ans.add(String.join(<span class="hljs-string">&quot; &quot;</span>,path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> idx ; i &lt; s.length() ;i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(idx,i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(set.contains(str))&#123;<br>                path.add(str);<br>                dfs(s,i+<span class="hljs-number">1</span>,path,set);<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><strong>贪心的本质就是每次都选择每一阶段的局部最优，从而达到全局最优</strong></p><p>唯一的难点就是如何通过局部最优，推出整体最优。</p><p>证明以上的结论的一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h3 id="最佳观光组合"><a href="#最佳观光组合" class="headerlink" title="最佳观光组合"></a><a href="https://leetcode.cn/problems/best-sightseeing-pair/">最佳观光组合</a></h3><p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。</p><p>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><blockquote><p>贪心遍历模拟</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> values[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; values.length; i++)&#123;<br>            ans = Math.max(ans, max + values[i] - i);<br>            max = Math.max(max, values[i] + i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分发糖果-字节hard"><a href="#分发糖果-字节hard" class="headerlink" title="分发糖果 [字节hard]"></a><a href="https://leetcode.cn/problems/candy/">分发糖果</a> [字节hard]</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><blockquote><p>两次遍历：</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>ratings.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>])&#123;<br>                dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>] &amp;&amp; dp[i] &lt;= dp[i+<span class="hljs-number">1</span>])&#123;<br>                dp[i] = dp[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>            res += dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优化常数级空间</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// inc 记录升序区间长度，dec记录降序区间长度，pre记录前一个同学的糖果。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, dec = <span class="hljs-number">0</span>, pre = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 升序区间，比前一个人多一个</span><br>            <span class="hljs-keyword">if</span> (ratings[i] &gt;= ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                dec = <span class="hljs-number">0</span>;<br>                pre = ratings[i] == ratings[i - <span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : pre + <span class="hljs-number">1</span>;<br>                ret += pre;<br>                inc = pre;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 降序区间，给当前的同学分配一个，并且给这个区间上所有人都多分配一个糖果</span><br>                dec++;<br>                <span class="hljs-comment">// 如果降序区间长度和升序相同， 则把升序区间最后一个同学加入降序区间。</span><br>                <span class="hljs-keyword">if</span> (dec == inc) &#123;<br>                    dec++;<br>                &#125;<br>                ret += dec;<br>                pre = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/description/">分发饼干</a></h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><blockquote><p>贪心：<br>首先对两个数组进行排序，然后从后往前遍历孩子的胃口数组</p><p>这样做的目的是，让最大的饼干尺寸满足胃口最大的孩子。从而能够满足越多数量的孩子</p><p>时间复杂度为 <code>O(mlog m + nlog n)</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Arrays.sort(g);<br>        Arrays.sort(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gIdx</span> <span class="hljs-operator">=</span> g.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sIdx</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; gIdx &gt;= <span class="hljs-number">0</span> ; gIdx --)&#123;<br>            <span class="hljs-keyword">if</span>(sIdx &gt;= <span class="hljs-number">0</span> &amp;&amp; g[gIdx] &lt;= s[sIdx])&#123;<br>                ans++;<br>                sIdx--;<br>            &#125;<br>            <br>        &#125;   <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>双指针：盛水容器的容量计算：底 × 高，左右两个指针分别指向数组的开头和结尾，此时底最大，然后不断收缩底边长度，以获取更多容量的容器。收缩途中记录最大值，最后返回最大值</p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            ans = Math.max(ans, (r-l)*Math.min(height[l], height[r]));<br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">摆动序列</a></h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><p><img src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p><blockquote><p>思路：<br>贪心</p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong>。</p><p>我们只需记录峰值个数</p><p>如何记录呢，通过两个变量<code>pre</code>来记录之前的坡度，<code>cur</code>来记录当前的坡度，如果二者正负值不同则有峰值出现，峰值+1</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n ; i++)&#123;<br>            cur = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>( (pre &gt;= <span class="hljs-number">0</span> &amp;&amp; cur &lt; <span class="hljs-number">0</span>) || (pre &lt;= <span class="hljs-number">0</span> &amp;&amp; cur &gt; <span class="hljs-number">0</span>))&#123;<br>                res++;<br>                pre = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大子数组和-1"><a href="#最大子数组和-1" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><blockquote><p>思路：</p><p>贪心，题目要求的是连续子数组和的最大值。</p><p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历<code>nums</code>，从头开始用sum累积，如果sum一旦加上<code>nums[i]</code>变为负数，那么就应该从<code>nums[i+1]</code>开始从0累积count了，因为已经变为负数的count，只会拖累总和。</p><p>时间复杂度: <code>O(n)</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i :nums)&#123;<br>            sum+= i;<br>            res = Math.max(sum, res);<br>            <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机 II</a></h3><p>​给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><blockquote><p>思路：</p><p>这道题允许重复购买股票，但是一段时间只能持有一只股票</p><p>如果使用贪心，那么我们应该低价买高价卖，比如第0天买，第3天卖利润为：<code>prices[3]-prices[0]</code></p><p>实际上这个等式是可以分解的：</p><p><code>prices[3]-prices[0] = prices[3]-prices[2] + (prices[2]-prices[1]) + (prices[1]-prices[0])</code></p><p>等于连续买卖利润之和。</p><p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><p>所以只收集正利润就是最大的利润</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; prices.length; i++)&#123;<br>            res += Math.max(prices[i] - prices[i-<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/description/">跳跃游戏</a></h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>本题的关键是跳跃可覆盖的范围！！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            k = Math.max(k, nums[i]+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/description/">跳跃游戏 II</a></h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用<strong>最少的跳跃次</strong>数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><blockquote><p>这道题本质还是计算覆盖面积，</p><p>但是因为要计算跳跃步数，我们需要计算两个覆盖范围，一个是当前的覆盖范围，一个是下一步的覆盖范围。</p><p>如果当前的下标到达了当前覆盖范围的边界，步数就要加一，然后更新当前覆盖范围，将下一步的覆盖范围赋值给当前的覆盖范围</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当前覆盖范围</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 步数统计</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 下一个的覆盖范围</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">// 计算覆盖范围</span><br>            next = Math.max(nums[i]+i, next);<br>            <span class="hljs-comment">// 当前下标已经到达当前的覆盖范围边界，需要更新</span><br>            <span class="hljs-keyword">if</span>(i == cur)&#123;<br>                <span class="hljs-comment">//如果看看当前范围是否覆盖最后一个位置</span><br>                <span class="hljs-keyword">if</span>(cur != nums.length - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 没有覆盖最后一个位置的话，步数+1</span><br>                    res++;<br>                    <span class="hljs-comment">// 更新范围</span><br>                    cur = next;<br>                    <span class="hljs-comment">// 如果下一个范围能够覆盖最后一个位置，则退出循环，因为此时的步数已经可以跳到最后的位置</span><br>                    <span class="hljs-keyword">if</span>(next &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">K 次取反后最大化的数组和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p><ul><li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li></ul><p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p><p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,2,3]</span>, k = 1<br>输出：5<br>解释：选择下标 1 ，nums 变为 <span class="hljs-comment">[4,-2,3]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,-1,0,2]</span>, k = 3<br>输出：6<br>解释：选择下标 (1, 2, 2) ，nums 变为 <span class="hljs-comment">[3,1,0,2]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [2,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,5,<span class="hljs-string">-4</span>], k = 2<br>输出：13<br>解释：选择下标 (1, 4) ，nums 变为 [2,3,<span class="hljs-string">-1</span>,5,4] 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>贪心的局部最优就是让绝对值最大的负数变为正数，全局最优就是整个数组和最大</p><p>如果所有负数都为正数，但是k还大于0，此时，就是对一个正序数组，如何转变k次正负让数组和最大</p><p>其实这个时候就只需要知道k的奇偶性，如果是偶数，则不用改变，如果是负数就改变数值最小的数即可。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSumAfterKNegations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        nums = IntStream<br>                .of(nums)<br>                .boxed()<br>                .sorted(((o1, o2) -&gt; Math.abs(o2)-Math.abs(o1)))<br>                .mapToInt(Integer::intValue).toArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>                nums[i] = -nums[i];<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) nums[len -<span class="hljs-number">1</span>] = - nums[len - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> Arrays.stream(nums).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode.cn/problems/gas-station/description/">加油站</a></h3><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>首先如果总油量减去耗油量是大于0 的，那么这辆车能够环路行使一周。</p><p>每个加油站的剩余量<code>rest[i] = gas[i]-cost[i]</code></p><p>我们选择剩余量大于0的加油站作为起点</p><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。</strong></p><p><strong>全局最优：找到可以跑一圈的起始位置</strong>。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cost.length; i++)&#123;<br>            cur += gas[i]-cost[i];<br>            total += gas[i]- cost[i];<br>            <span class="hljs-keyword">if</span>(cur &lt; <span class="hljs-number">0</span>)&#123;<br>                start = i+<span class="hljs-number">1</span>;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(total &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> start;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">根据身高重建队列</a></h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>这个题需要按两个来排序，一个是身高的高度，一个是大于等于它这个身高的人数。</p><p>那么如果两个因素都一起考虑的话，这道题会做不出来</p><p>正确的做法是先确定一个变量，再贪心另一个变量。</p><p>我们按身高进行排序，从高到低排序，然后优先按身高高的人的k值来进行插入</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people,(o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> o2[<span class="hljs-number">0</span>]-o1[<span class="hljs-number">0</span>];<br>        &#125;);<br>        LinkedList&lt;<span class="hljs-type">int</span>[] &gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] p : people)&#123;<br>            que.add(p[<span class="hljs-number">1</span>], p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> que.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">用最少数量的箭引爆气球</a></h3><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x = 6处射出箭，击破气球<span class="hljs-comment">[2,8]</span>和<span class="hljs-comment">[1,6]</span>。<br>-在x = 11处发射箭，击破气球<span class="hljs-comment">[10,16]</span>和<span class="hljs-comment">[7,12]</span>。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>这题读完之后会发现和合并区间类似，如果气球的区间有重叠的话，那么就用一根弓箭就可以引爆两个气球。</p><p>就是求气球的非交叉区间的个数（因为交叉的区间可以用一根箭引爆）</p><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p><p>弓箭发射的点就是这两个区间的右端点的最小值。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-keyword">if</span> (points.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(points,(o1, o2) -&gt; Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; points[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">无重叠区间</a></h3><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,3]</span>]</span><br>输出: 1<br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>其实看完题就知道应该要排序了，但是如何排序呢？</p><p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。</p><p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题转换成求<strong>非交叉区间的最大个数。</strong></p><p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals,(o1, o2) -&gt; o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(end &lt;= intervals[i][<span class="hljs-number">0</span>])&#123;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.length - count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/description/">划分字母区间</a></h3><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-symbol">S</span> = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间"></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">27</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            hash[c-<span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt;s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            right = Math.max(right, hash[c-<span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span>(i == right)&#123;<br>                ans.add(right - left + <span class="hljs-number">1</span>);<br>                left = i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/description/">合并区间</a></h3><p>​以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>此题一定要排序，那么按照左边界排序，还是右边界排序呢？</p><p>都可以！</p><p>那么我按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, ((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>        &#125;));<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; intervals[i][<span class="hljs-number">0</span>])&#123;<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start,intervals[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;);<br>                start = intervals[i][<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                intervals[i][<span class="hljs-number">1</span>] = Math.max(intervals[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start,intervals[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()][ans.get(<span class="hljs-number">0</span>).length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; ans.size(); i++)&#123;<br>            res[i] = ans.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导<code>dp</code> 数组</li></ol><h3 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></h3><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><blockquote><p>对于所有的数字，只有两类：</p><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。<br>       举例：<br>      0 &#x3D; 0       1 &#x3D; 1<br>      2 &#x3D; 10      3 &#x3D; 11<br>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。<br>        举例：<br>       2 &#x3D; 10       4 &#x3D; 100       8 &#x3D; 1000<br>       3 &#x3D; 11       6 &#x3D; 110       12 &#x3D; 1100</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n ;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                res[i] = res[i/<span class="hljs-number">2</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[i] = res[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/description/">整数拆分</a></h3><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 <em>你可以获得的最大乘积</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>动态规划：</p><ol><li><p>确定<code>dp</code>数组以及下标的含义：</p><p>我们对这道题定义<code>dp[i]</code>表示拆分数字i，得到的最大乘积为<code>dp[i]</code></p></li><li><p>确定递推公式</p><p>如何得到<code>dp[i]</code>呢？</p><p>其实可以从1遍历到 j (j &lt; i-1)，然后就由两种渠道得到<code>dp[i]</code>:</p><ul><li><code>dp[i] = j * (i - j)</code></li><li>继续拆分(i-j), 则i-j 拆分后的最大乘积为<code>dp[i-j]</code> 所以 <code>dp[i] = j * dp[i-j]</code></li></ul><p>也可以这么理解，<code>j * (i - j) </code> 是单纯的把整数拆分为两个数相乘，而<code>j * dp[i - j]</code>是拆分成两个以及两个以上的个数相乘。</p></li><li><p>初始化</p><p>因为<code>dp[0]</code> 和 <code>dp[1]</code>是无意义的，所以初始化<code>dp[2] = 1</code></p></li><li><p>确定遍历顺序</p><p>确定遍历顺序，先来看看递归公式：dp[i] &#x3D; max(dp[i], max((i - j) * i, dp[i - j] * j));</p><p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p><p>枚举j的时候，是从1开始的。i是从3开始，这样<code>dp[i - j]</code>就是<code>dp[2]</code>正好可以通过我们初始化的数值求出来。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i - <span class="hljs-number">1</span>; j++)&#123;<br>                dp[i] = Math.max(dp[i],Math.max((i-j)*j, j*dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><ol><li><p>确定dp数组及其下标的含义</p><p><code>dp[i]</code> 表示 1 到 i 节点组成的二叉搜索树的数目。</p></li><li><p>确定递推公式</p><p>j从1到i遍历：<code>dp[i] += dp[以j为头结点的左子树的数目]*dp[以j为头结点的右子树的数目]</code></p><p>即<code>dp[i] += dp[j-1] * dp[i-j]</code></p></li><li><p>初始化</p><p><code>dp[0] = 0;</code></p></li><li><p>确定遍历顺序</p><p>首先一定是遍历节点数，从递归公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 1到i为节点组成的二叉搜索树的个数为dp[i]。</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            有2个元素的搜索树数量就是dp[2]。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            有1个元素的搜索树数量就是dp[1]。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            有0个元素的搜索树数量就是dp[0]</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节</span><br>        dp[<span class="hljs-number">0</span>]  = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/description/">打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>动态规划</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i]</code>表示[0,i]这个区间内的房屋偷的的最高金额</p></li><li><p>确定递推关系</p><p><code>dp[i]</code>如果偷下标为i的房屋的话，那么金额就等于<code>dp[i-2]+nums[i]</code>因为它不能投相邻的</p><p>如果不偷的话，<code>dp[i] = dp[i-1]</code></p><p>所以<code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p></li><li><p>初始化</p><p><code>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);</code></p></li><li><p>遍历顺序</p><p>从头到尾遍历<code>nums</code></p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">2</span>]+nums[i], dp[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/description/">打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><blockquote><p>这道题与上一题不同的地方就是，房子是围成一圈的。</p><p>就是可以先考虑包含首个元素，但是不包含尾部元素。</p><p>然后再考虑包含尾部元素，不包含首部元素。</p><p>求这两个情况的最大值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 选了第一家</span><br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 选理第一家就不能选最后一家，所以是nums.length-1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span>  dp[nums.length - <span class="hljs-number">1</span> ];<br>        Arrays.fill(dp,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 不选第一家</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= nums.length; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], nums[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 不选第一家就能选最后一家所以是nums.length</span><br>        <span class="hljs-keyword">return</span>  Math.max(res, dp[nums.length]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好理解版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> robRange(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">2</span>); <span class="hljs-comment">// 偷第一家，不偷最后一家</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> robRange(nums, <span class="hljs-number">1</span>, nums.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 不偷第一家，偷最后一家</span><br>        <span class="hljs-keyword">return</span> max(result1, result2);<br>    &#125;<br>    <span class="hljs-comment">// 198.打家劫舍的逻辑</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">robRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (end == start) <span class="hljs-keyword">return</span> nums[start];<br>        vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(nums.size()</span>);<br>        dp[start] = nums[start];<br>        dp[start + <span class="hljs-number">1</span>] = max(nums[start], nums[start + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i] = max(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/description/">打家劫舍 III</a></h3><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: root = [3,2,3,null,3,null,1]<br>输出:<span class="hljs-number"> 7 </span><br>解释: 小偷一晚能够盗取的最高金额<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>= 7<br></code></pre></td></tr></table></figure><blockquote><p>本题把数组换成了树，</p><p>我们可以记忆化搜索这颗树</p><p>情况分成偷父节点和不偷父节点，取最大值</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.left ==<span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val;<br>        <span class="hljs-keyword">if</span>(map.containsKey(root)) <span class="hljs-keyword">return</span> map.get(root);<br>        <span class="hljs-comment">// 偷父节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>) val1 += rob(root.left.left)+rob(root.left.right); <br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>) val1 += rob(root.right.right) + rob(root.right.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 不偷父节点</span><br>        val2 += rob(root.left) + rob(root.right);<br>        map.put(root,Math.max(val1,val2));<br>        <span class="hljs-keyword">return</span> Math.max(val1,val2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买卖股票的最佳时机</a></h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><blockquote><p>贪心：</p><p>取最左边的最小值和取最右边的最大值，得到的差值就是最大利润</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<br>            left = Math.min(left, prices[i]);<br>            result = Math.max(result, prices[i]-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态规划</p><ol><li><p>确定<code>dp</code>数组及其下标含义</p><p>我们定义</p><p><code>dp[i][0]</code>表示第i天持有股票的最大现金。</p><p><code>dp[i][1]</code>表示第i天不持有股票的最大现金。</p><p>“持有”不代表买入，如果当天持有，可能是当天买入，也可能是之前已经买入但没卖出。</p></li><li><p>确定递推公式</p><p>根据<code>dp</code>数组的定义，我们可以推出</p><p>第i天持有股票的最大现金：</p><p>主要来源就是：前一天也持有股票，或者第i天买入了，所以公式如下：</p><p><code>dp[i][0] = max(dp[i-1][0],-prices[i])</code>;</p><p>这是因为本体只能买卖一次，所以某天买入了股票的现金一定是-prices[i]</p><p>第i天不持有股票的最大现金：</p><p>主要来源就是前一天也不持有股票，或者前一天持有股票，今天卖出去了，所以公式如下：</p><p><code>dp[i][1] = max(dp[i-1][1],prices[i]+dp[i-1][0])</code></p></li><li><p>初始化</p><p><code>dp[0][0]</code>表示第0天持有股票，那么金额就是:-prices[0];</p><p><code>dp[0][1]</code>表示第0天不持有股票，那么金额就是0</p></li><li><p>遍历顺序</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], -prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II-1"><a href="#买卖股票的最佳时机-II-1" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">买卖股票的最佳时机 II</a></h3><p>​给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>贪心的做法我们在贪心的专题已经做过了，就是分割每日利润。只加正数即可</p></blockquote><blockquote><p>这道题的上一题不同的点是，我们<strong>买卖的次数可以有很多次</strong>，但是我们同一时间最多只能持有一个股票。</p><p>动态规划：</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p>我们定义</p><p><code>dp[i][0]</code>表示第i天持有股票的最大现金。</p><p><code>dp[i][1]</code>表示第i天不持有股票的最大现金。</p></li><li><p>确定递归公式</p><p>第i天持有股票的最大现金：</p><p>主要来源就是：第i-1天也持有股票，或者第i-1天不持有股票，但是今天持有股票。因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。所以金额就等于前一天不持有股票的金额减去今天股票的价格。</p><p><code>dp[i][0] =max(dp[i-1][0],dp[i-1][1]-prices[i])</code></p><p>第i天不持有股票的最大现金：</p><p>主要来源就是：第i-1天也不持有股票，或者第i-1天持有股票，但是今天卖出了。</p><p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])</code></p></li><li><p>初始化</p><p>和上题一样</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; prices.length; i++)&#123;<br>            res += Math.max(prices[i] - prices[i-<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dynamic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span>&#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 第i天持有股票的收益</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 第i天不持有股票的收益</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; prices.length; i++)&#123;<br>            <span class="hljs-comment">// 第i天不持股，是因为第i-1天也不持股，或者第i-1天持股，然后今天卖了</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], prices[i]+dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 第i天持股，是因为第i-1天也持股，或者i-1天不持股，今天买了</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">买卖股票的最佳时机 III</a></h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [3,3,5,0,0,3,1,4]<br>输出：6<br>解释：在第<span class="hljs-number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="hljs-number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br>     随后，在第<span class="hljs-number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>这道题的难点就是它对买卖次数限制了至多能买卖两次，意味着它可以不买卖，可以买卖一次，可以买卖两次</p><p>我们需要对原来两个状态进行拓展</p><p>一天一共就有五个状态，</p><p>​0.没有操作</p><ol><li><p>第一次买入</p></li><li><p>第一次卖出</p></li><li><p>第二次买入</p></li><li><p>第二次卖出</p></li><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i][j]</code>表示第i天，j为上述五个状态时的金额</p></li><li><p>确定递推公式</p><p><code>dp[i][1]，</code><strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><p>达到<code>dp[i][1]</code>状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么<code>dp[i][1] = dp[i-1][0] - prices[i]</code></li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：<code>dp[i][1] = dp[i - 1][1]</code></li></ul><p>同理<code>dp[i][2]</code>也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：<code>dp[i][2] = dp[i - 1][2]</code></li></ul><p>所以<code>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</code></p><p>同理可推出剩下状态部分：</p><p><code>dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</code></p><p><code>dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</code></p></li><li><p>初始化</p><p>第0天没有操作，这个最容易想到，就是0，即：<code>dp[0][0] = 0;</code></p><p>第0天做第一次买入的操作，<code>dp[0][1] = -prices[0];</code></p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p><p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p><p>所以<code>dp[0][2] = 0;</code></p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：<code>dp[0][3] = -prices[0];</code></p><p>同理第二次卖出初始化<code>dp[0][4] = 0;</code></p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">5</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">买卖股票的最佳时机 IV</a></h3><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第<span class="hljs-number"> 1 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 2 </span>天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 =<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>这道题是上一道题的进阶，即要求可以完成k次</p><p>回顾一下上一道题的<code>dp</code>数组的定义：</p><p>使用二维数组<code> dp[i][j] ：</code>第i天的状态为j，所剩下的最大现金是<code>dp[i][j]</code></p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li></ul><p>可以发现，除了0以外 j为奇数就是买入，j为偶数就卖出。</p><p>所以对于可以买卖k次时，<code>dp</code>数组有 <code>2*k+1</code>个状态。</p><p>所以状态转移的方程可以用一个for循环来替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>*k - <span class="hljs-number">1</span>; j+= <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">// 第j+1次买入</span><br>    dp[i][j+<span class="hljs-number">1</span>] = Math.min(dp[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j] - prices[i]);<br>    <span class="hljs-comment">// 第j+1次卖出</span><br>    dp[i][j+<span class="hljs-number">2</span>] = Math.min(dp[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">2</span>],dp[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] + prices[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化时，和上一题一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span>*k ; j+=<span class="hljs-number">2</span>)&#123;<br>    dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * k; j += <span class="hljs-number">2</span>) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//状态转移</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// 第i天第j+1次买入（买入不是当天就买入）</span><br>                dp[i][j + <span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j] - prices[i]);<br>                <span class="hljs-comment">// 第i天第J+1次卖出</span><br>                dp[i][j + <span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">最佳买卖股票时机含冷冻期</a></h3><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [1,2,3,0,2]</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></code></pre></td></tr></table></figure><blockquote><p>这道题相对于买卖股票Ⅱ多了一个冷却期。</p><p>多了个冷却期，状态就会多一些，我们可以列举一下有哪些状态：</p><ul><li>0：买入股票的状态——要么今天买入，要么前几天买了，一直没卖</li><li>1：卖出的状态：前两天就已经卖出了股票，过了冷却期，一直没买股票</li><li>2：今天刚卖股票</li><li>3：今天为冷却期，无法操作</li></ul><p>这里不赘述<code>dp</code>数组的含义</p><p>我们直接进入确定递推公式阶段</p><p>对于状态0：即买入股票的状态</p><p><code>dp[i][0]</code>:</p><ul><li><p>前一天已经持有股票：<code>dp[i][0] = dp[i-1][0]</code>;</p></li><li><p>今天买股票:</p><ul><li><p>前一天是冷却期，今天买那么金额就是冷却期时的金钱减去今天股票价格：</p><p><code>dp[i][0] = dp[i-1][3]-prices[i]</code></p></li><li><p>前一天是卖出的状态但是过了冷却期：<code>dp[i][0] = dp[i-1][1]-prices[i]</code></p></li></ul></li></ul><p><code>dp[i][0] = max(dp[i-1][0],max(dp[i-1][3],dp[i-1][1]) - prices[i])</code></p><p>保持卖出股票的状态</p><p><code>dp[i][1]</code>:</p><ul><li>前一天就是卖出股票的状态：<code>dp[i][1] = dp[i-1][1]</code></li><li>前一天是冷冻期：<code>dp[i][1] = dp[i-1][3]</code></li></ul><p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][3])</code></p><p>今天卖出股票</p><p><code>dp[i][2]</code>:</p><ul><li>前一天是买入了股票的状态，今天可以卖出股票</li></ul><p><code>dp[i][2] = dp[i-1][0]+ prices[i]</code></p><p>冷却状态：</p><p><code>dp[i][3]</code></p><ul><li>前一天刚卖出股票：<code>dp[i][3] = dp[i-1][2]</code></li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">4</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])-prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            dp[i][<span class="hljs-number">3</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], Math.max(dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>状态压缩<br><code>dp[i][0]</code>表示第i天持有股票的收益</p><p><code>dp[i][1]</code>表示第i天不持有股票的收益</p><p>会出现以下两种情况：</p><ul><li>第i天是冷静期，不能以<code>dp[i-1][1]</code>购买股票，只能以<code>dp[i-2][1]</code>购买股票</li><li>第i天不是冷静期，说明第i-1天没有卖出股票，则<code>dp[i-1][1] == dp[i-2][1]</code>,所以也是<code>dp[i-2][1]- prices[i]</code></li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= prices.length; i++) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            dp[i][0] 第i天持有股票收益;</span><br><span class="hljs-comment">            dp[i][1] 第i天不持有股票收益;</span><br><span class="hljs-comment">            情况一：第i天是冷静期，不能以dp[i-1][1]购买股票,所以以dp[i - 2][1]买股票，没问题</span><br><span class="hljs-comment">            情况二：第i天不是冷静期，理论上应该以dp[i-1][1]购买股票，但是第i天不是冷静期说明，第i-1天没有卖出股票，</span><br><span class="hljs-comment">                则dp[i-1][1]=dp[i-2][1],所以可以用dp[i-2][1]买股票，没问题</span><br><span class="hljs-comment">             */</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i - <span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">买卖股票的最佳时机含手续费</a></h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><blockquote><p>这道题和买卖股票Ⅱ几乎一样，</p><p>我们直接将推导递推公式的过程：</p><p><code>dp[i][0]</code>表示第i天持有股票的收益</p><p><code>dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])</code></p><p><code>dp[i][1]</code>表示第i天不持有股票的收益</p><p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]-fee)</code></p><p>区别就是卖出时多个减去手续费的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices, <span class="hljs-type">int</span> fee)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> )<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+prices[i]-fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a></h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>子序列问题常见的解法就是动态规划</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i]</code>表示i之前包括i的以<code>nums[i]</code>为结尾最长上升子序列的长度。</p></li><li><p>确定递推公式</p><p>位置i的最长上升子序列等于j从0-i-1各个位置的最长上升子序列+1的最大值。</p><p>即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>即如果i位置的数字大于j数字的位置，那么这个子序列就是以<code>nums[j]</code>为结尾的子序列长度加1.</p></li><li><p>初始化</p><p>都初始化为1，因为子序列至少包含一个数字</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i ;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i] &gt; res) res = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>O(N^2)的复杂度是难以接受的，遍历dp列表要O(N)，计算<code>dp[k]</code>需要O(N)</p><p>是否可以通过重新设计状态定义，使整个 dp 为一个排序列表；这样在计算每个 dp[k] 时，就可以通过二分法遍历 [0,k)[0,k) 区间元素，将此部分复杂度由 O(N) 降至 O(logN)。</p><p>新状态定义为**<code>dp[i]</code>表示长度为i+1的子序列最小尾部元素的值**</p><p>转移方程：</p><p>我们要求的是最长递增子序列的长度，用一个遍历<code>res</code>记录<code>dp[]</code>数组的长度。代表当前最长上升子序列的长度。然后因为<code>dp</code>数组在<code>j∈[0,res]</code>中是递增的，我们在这个范围内对遍历到的<code>num</code>进行二分查找：</p><ul><li>如果存在<code>dp[j]&gt;num，即存在</code>num的上界，则更新<code>dp[j] = num</code>，因为我们定义<code>dp[j]</code>为长度为j+1的子序列的最小尾部的元素的值。</li><li>如果不存在<code>dp[j] &gt; num</code>，表示这个值在当前结果长度res的递增子序列中是最大值，可以继续递增，所以更新当前<code>dp[res] = num</code>并且res++</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// dp[i]表示长度为i+1的子序列最小尾部元素的值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> , hi = maxL;<br>            <span class="hljs-comment">// 这个二分之前说过，是查找num在dp中的上界。</span><br>            <span class="hljs-comment">// 如果存在上界，即上界对应长度的最小尾部可以更新。</span><br>            <span class="hljs-comment">// 如果不存在上界，则意味着长度增加。</span><br>            <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + (hi-lo)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(dp[mid] &lt; num)&#123;<br>                    lo = mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    hi = mid;<br>                &#125;<br>            &#125;<br>            dp[lo] = num;<br>            <span class="hljs-keyword">if</span>(lo == maxL) maxL++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxL;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">最长连续递增序列</a></h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span><br>输出：3<br>解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。<br>尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br></code></pre></td></tr></table></figure><blockquote><p>这道题其实是个子数组问题</p><p>动态规划：</p><ol><li><p>确定<code>dp</code>及其下标的含义</p><p><code>dp[i]</code>表示以i为结尾的数组的最长连续递增子序列的长度。</p></li><li><p>确定递推公式</p><p>和递增子序列不同，因为要求连续所以我们比较的是i+1 和 i</p><p>如果<code>nums[i+1] &gt; nums[i] </code>则<code>dp[i+1] = dp[i]+1</code></p></li><li><p>初始化</p><p>均为1</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>] &gt; nums[i])&#123;<br>                dp[i+<span class="hljs-number">1</span>] = dp[i]+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>] &gt; res) res = dp[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这道题也可以使用贪心</p><p>如果一个数小于它前一个数，那么更新这个连续递增子序列的起始位置。</p><p>然后遍历时记录最长的长度。</p><p>详细见代码</p><p>滑动窗口也是这个思想</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums[i-<span class="hljs-number">1</span>])&#123;<br>                start = i;<br>            &#125;<br>            res = Math.max(res, i-start+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">最长重复子数组</a></h3><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,2,1]</span>, nums2 = <span class="hljs-comment">[3,2,1,4,7]</span><br>输出：3<br>解释：长度最长的公共子数组是 <span class="hljs-comment">[3,2,1]</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>经典动态规划的题目</p><p>这里和之前两题都差不多</p><p>定义<code>dp[i][j]</code>表示以<code>nums1[i-1]</code>和<code>nums2[j-1]</code>为结尾的,二者的最大公共后缀长度</p><p>显然只有当<code>nums1[i-1]==nums2[j-1]</code>时 <code>dp[i][j] = dp[i-1][j-1]+1</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                res = Math.max(dp[i][j], res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态规划的时间复杂度是O(NM)其实是很慢的</p></blockquote><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">最长公共子序列</a></h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p> <strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><blockquote><p>子序列问题：动态规划</p><p>确定<code>dp</code>数组及其下标的含义：</p><p><code>dp[i][j]</code>：长度为[0, i - 1]的字符串<code>text1</code>与长度为[0, j - 1]的字符串<code>text2</code>的最长公共子序列的长度为<code>dp[i][j]</code></p><p>递推公式：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">主要就是两大情况： text1<span class="hljs-comment">[i - 1]</span> 与 text2<span class="hljs-comment">[j - 1]</span>相同，text1<span class="hljs-comment">[i - 1]</span> 与 text2<span class="hljs-comment">[j - 1]</span>不相同<br><br>如果text1<span class="hljs-comment">[i - 1]</span> 与 text2<span class="hljs-comment">[j - 1]</span>相同，那么找到了一个公共元素，所以dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> + 1;<br><br>如果text1<span class="hljs-comment">[i - 1]</span> 与 text2<span class="hljs-comment">[j - 1]</span>不相同，那就看看text1<span class="hljs-comment">[0, i - 2]</span>与text2<span class="hljs-comment">[0, j - 1]</span>的最长公共子序列 和 text1<span class="hljs-comment">[0, i - 1]</span>与text2<span class="hljs-comment">[0, j - 2]</span>的最长公共子序列，取最大的。<br><br>即：dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>);<br></code></pre></td></tr></table></figure></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1.charAt(i-<span class="hljs-number">1</span>) == text2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/description/">不相交的线</a></h3><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p>示例：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2</span><br>解释：可以画出两条不交叉的线，如上图所示。 <br>但无法画出第三条不相交的直线，因为从 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">4</span> 到 <span class="hljs-symbol">nums2</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">4</span> 的直线将与从 <span class="hljs-symbol">nums1</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span> 到 <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span> 的直线相交。<br></code></pre></td></tr></table></figure><blockquote><p>理解题目是第一步</p><p>这个题目其实还是找子序列问题，就是找两个数组的最长子序列和上一题一模一样</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxUncrossedLines</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大子数组和-2"><a href="#最大子数组和-2" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><blockquote><p>这道题在贪心的时候也写了一次。</p><p>现在用动态规划的思想来解决：</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p>**<code>dp[i]</code>：包括下标i之前的最大连续子序列和为<code>dp[i]</code>**。</p></li><li><p>确定递推公式</p><p><code>dp[i]</code>只有两个方向可以推出来：</p><ul><li><code>dp[i - 1] + nums[i]</code>，即：<code>nums[i]</code>加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>一定是取最大的，所以<code>dp[i] = max(dp[i - 1] + nums[i], nums[i]);</code></p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>] ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i]);<br>            res = Math.max(res,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大子数组乘积-https-leetcode-cn-problems-maximum-product-subarray-字节Hard"><a href="#最大子数组乘积-https-leetcode-cn-problems-maximum-product-subarray-字节Hard" class="headerlink" title="[最大子数组乘积][https://leetcode.cn/problems/maximum-product-subarray/] [字节Hard]"></a>[最大子数组乘积][<a href="https://leetcode.cn/problems/maximum-product-subarray/]">https://leetcode.cn/problems/maximum-product-subarray/]</a> [字节Hard]</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><p>子数组 是数组的连续子序列。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><blockquote><p>这道题和最大子数组和类似</p><p>但是dp数组可不是那题的含义。</p><p>因为存在负数，乘积可能是会从最大的变到最小，从最小的变到最大。所以除了记录最大乘积之外，还有记录一个最小的乘积</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] max = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        max[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span>nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; n ;i++)&#123;<br>            max[i] = Math.max(max[i-<span class="hljs-number">1</span>]*nums[i],Math.max(min[i-<span class="hljs-number">1</span>]*nums[i],nums[i]));<br>            min[i] = Math.min(min[i-<span class="hljs-number">1</span>]*nums[i],Math.min(max[i-<span class="hljs-number">1</span>]*nums[i],nums[i]));<br>            res = Math.max(max[i],res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/description/">判断子序列</a></h3><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始<strong>字符串删除</strong>一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 <code>S1, S2, ... , Sk </code>其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;ahbgdc&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><ol><li>确定<code>dp</code>数组（dp table）以及下标的含义</li></ol><p>**<code>dp[i][j] </code>表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为<code>dp[i][j]</code>**。</p><ol start="2"><li>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</li></ol><ul><li>if (s[i - 1] &#x3D;&#x3D; t[j - 1])<ul><li>t中找到了一个字符在s中也出现了</li></ul></li><li>if (s[i - 1] !&#x3D; t[j - 1])<ul><li>相当于t要删除元素，继续匹配</li></ul></li></ul><p>if (s[i - 1] &#x3D;&#x3D; t[j - 1])，那么<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code>，因为找到了一个相同的字符，相同子序列长度自然要在<code>dp[i-1][j-1]</code>的基础上加1（<strong>如果不理解，在回看一下<code>dp[i][j]</code>的定义</strong>）</p><p>if (s[i - 1] !&#x3D; t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么<code>dp[i][j] </code>的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：<code>dp[i][j] = dp[i][j - 1];</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n] == m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/description/">不同的子序列</a></h3><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <strong><code>s</code> 的子序列中 <code>t</code> 出现的个数。</strong></p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;rabbbit&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;rabbit&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">&quot;rabbit&quot;</span> 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p><strong><code>dp[i][j]</code>：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</strong></p></li><li><p>确定递推公式</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul><p>当s[i - 1] 与 t[j - 1]相等时，<code>dp[i][j]</code>可以有两部分组成。</p><p>一部分是用s[i - 1]来匹配，那么个数为<code>dp[i - 1][j - 1]</code>。</p><p>一部分是不用s[i - 1]来匹配，个数为<code>dp[i - 1][j]</code>。</p><p>所以当s[i - 1] 与 t[j - 1]相等时，<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</code></p><p>当s[i - 1] 与 t[j - 1]不相等时，<code>dp[i][j]</code>只有一部分组成，不用s[i - 1]来匹配，即：<code>dp[i - 1][j]</code></p><p>所以递推公式为：<code>dp[i][j] = dp[i - 1][j];</code></p></li><li><p>初始化</p><p><code>dp[i][0]</code>一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p><p>那么<code>dp[0][j]</code>一定都是0，s如论如何也变成不了t。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span> ; j &lt;= n; j++)&#123;<br>                <span class="hljs-comment">// 当前的字符匹配到了</span><br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">两个字符串的删除操作</a></h3><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">word1</span> = <span class="hljs-string">&quot;sea&quot;</span>, <span class="hljs-attr">word2</span> = <span class="hljs-string">&quot;eat&quot;</span><br>输出: <span class="hljs-number">2</span><br>解释: 第一步将 <span class="hljs-string">&quot;sea&quot;</span> 变为 <span class="hljs-string">&quot;ea&quot;</span> ，第二步将 <span class="hljs-string">&quot;eat &quot;</span>变为 <span class="hljs-string">&quot;ea&quot;</span><br></code></pre></td></tr></table></figure><blockquote><ol><li><p>确定dp数组及其下标的含义</p><p><code>dp[i][j]</code>表示word1以i-1下标的字符串和word2以j-1下标的字符串相同所需的最小步数</p></li><li><p>确定递推公式</p><p>如果word1[i-1] &#x3D;&#x3D; word2[j-1] 那么<code>dp[i][j] = dp[i-1][j-1]</code></p><p>如果word1[i-1] !&#x3D; word2[j-1] 那么有：</p><ul><li>删除word1[j-1] 最少操作次数： <code>dp[i-1][j]+1</code></li><li>删除word2[j-1] 最少操作次数：<code>dp[i][j-1]+1</code></li><li>两个都删除 最少操作次数：<code>dp[i-1][j-1]+2</code></li></ul><p>取最小值：<code>dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+2)</code></p></li><li><p>初始化</p><p><code>dp[i][0]</code>表示如果以word1下标i-1的字符串变成空字符串时，需要的最小步数：就是i</p><p><code>dp[0][j]</code>同理是j</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, Math.min(dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编辑距离-字节hard"><a href="#编辑距离-字节hard" class="headerlink" title="编辑距离  [字节hard]"></a><a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a>  [字节hard]</h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>确定dp数组及其下标的含义</p><p><code>dp[i][j]</code>word1以下标i-1字符结尾的字符串转换成word2以j-1字符结尾的字符串所使用的最少操作数。</p></li><li><p>确定递推公式</p><p>如果word1[i-1] &#x3D;&#x3D; word2[j-1]，那么就不需要操作：<code>dp[i][j] = dp[i-1][j-1]</code></p><p>如果word1[i-1] !&#x3D; word2[j-1]， 那么就涉及到三种操作</p><ul><li>修改word1[i-1]:需要步骤：<code>dp[i-1][j-1]+1</code></li><li>删除word1[i-1]:所需步骤：<code>dp[i-1][j]+1</code></li><li>删除word2[j-1]:所需步骤：<code>dp[i][j-1]+1</code></li><li>增加和删除是同一种情况。</li></ul></li><li><p>初始化</p><p>初始化和上一题一样。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-comment">// 第一个字符串的前i个子串到第二个字符串的前j个子串的编辑距离</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n ; i++) dp[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a></h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>中心拓展</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历每一个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i&lt;n;i++)&#123;<br>            <span class="hljs-comment">// 中心位置可能是两个字符，也可能是一个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt;= <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r))&#123;<br>                    l--;<br>                    r++;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态规划</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>布尔类型的<code>dp[i][j]</code>：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</p><ol start="2"><li>确定递推公式</li></ol><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，<code>dp[i][j]</code>一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true。</li></ul><ol start="3"><li><p>初始化</p><p>初始化为false</p></li><li><p>遍历顺序</p><p>首先从递推公式中可以看出，情况三是根据<code>dp[i + 1][j - 1]</code>是否为true</p><p><strong>所以一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong></p></li></ol></blockquote><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-comment">// 这个遍历过程也是类似于中心扩展</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i ; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">1</span>)&#123;<br>                        res++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])&#123;<br>                        res++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Manacher </p><p>马拉车算法：</p><ol><li><p>把字符串转换成马拉车字符串</p></li><li><p>计算下标为i的回文半径 r[i] </p></li><li><p>当前最大回文的右端点 rm 和中心点 c</p></li><li><p>计算方法：</p><p>如果当前rm &lt; i 则初始化r[i] &#x3D; 1</p><p>如果 rm &gt; i 则初始化 r[i] &#x3D;min(r[j] ,rm-i+1); j 为i关于c的对称点 (j &#x3D; 2 * c - i );</p><p>然后再向外扩展，并更新r[i]，如果 i + r[i] - 1 &gt;  rm 则更新rm 和 c </p><p>**然后统计r[i] 中 长度&gt;2的个数。： ans +&#x3D; r[i] &#x2F; 2;**（这部分因题而异）</p></li></ol><p>这个时候我们需要注意的是不能让下标越界，有一个很简单的办法，就是在开头加一个 $，并在结尾加一个 !，这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;$#&quot;</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sb.append(s.charAt(i));<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        n = sb.length(); <span class="hljs-comment">// 这两步不能反过来</span><br>        sb.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br>        <span class="hljs-type">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rmax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 初始化回文半径</span><br>            r[i] = i &lt;= rmax ? Math.min(r[<span class="hljs-number">2</span> * c - i], rmax - i + <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (sb.charAt(i + r[i]) == sb.charAt(i - r[i])) &#123;<br>                ++r[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i + r[i] - <span class="hljs-number">1</span> &gt; rmax) &#123;<br>                rmax = i + r[i] - <span class="hljs-number">1</span>;<br>                c = i;<br>            &#125;<br>            res += r[i] / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><blockquote><p>中心扩展</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length()  == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i&lt;n;i++)&#123;<br>            <span class="hljs-comment">// 中心位置可能是两个字符，也可能是一个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt;= <span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r))&#123;<br>                    l--;<br>                    r++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(r - l - <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    maxLen = r - l - <span class="hljs-number">1</span>;<br>                    maxStart = l ;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart+<span class="hljs-number">1</span> , maxStart+maxLen+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态规划</p><p>确定dp数组及其下标的含义</p><p><code>dp[i][j]</code>表示字符串s[i,j]是否为回文字符串</p><p>确定递推公式</p><p>如果s[i] &#x3D;&#x3D;s[j]：</p><p>那么<code>dp[i][j] |= dp[i+1][j-1]</code></p><p>否则<code>dp[i][j] = false</code></p><p>初始化：</p><p>我们可以按长度来初始化，即单个字符，肯定是回文字符串<code>dp[i][i] = true</code></p></blockquote><blockquote><p>这道题dp数组的含义和上一题回文子串的dp数组一样，故同样可以使用上一题的解法</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n -<span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i ; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    <span class="hljs-keyword">if</span>(j-i &lt;= <span class="hljs-number">1</span>)&#123;<br>                        dp[i][j]  = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])&#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    begin = i;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin, begin+maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Manacher算法</p><p>和上一题一样，我们只是需要在找到更长的回文长度时，更新左部右部即可。</p><p>如果i点的回文半径为r[i]，则这个回文串（包含’#’）的左部为:[ i-r[i]+ 1, i+r[i] -1];</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        StringBuilder t= <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;$#&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            t.append(s.charAt(i));<br>            t.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        &#125;<br>        n = t.length();<br>        t.append(<span class="hljs-string">&#x27;!&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rmax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            r[i] = i &lt;= rmax ? Math.min(r[<span class="hljs-number">2</span> * c - i], rmax - i + <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(t.charAt(i+r[i]) == t.charAt(i-r[i]))&#123;<br>                ++r[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i+r[i] -<span class="hljs-number">1</span>  &gt; rmax)&#123;<br>                rmax  = i + r[i] - <span class="hljs-number">1</span>;<br>                c=i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(len &lt; r[i] - <span class="hljs-number">1</span>)&#123;<br>                left = i-r[i] +<span class="hljs-number">1</span> ;<br>                right = i+r[i] -<span class="hljs-number">1</span>;<br>                len = r[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left ;i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(t.charAt(i) != <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                sb.append(t.charAt(i));<br>            &#125;<br>        &#125;<br>        res = sb.toString();<br>        <span class="hljs-keyword">return</span> res ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">最长回文子序列</a></h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbbab&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bbbb&quot;</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>确定dp数组及其下标的含义</p><p><code>dp[i][j]</code>表示区间[i,j]之间最长回文子序列的长度。</p><p>确定递推公式：</p><p>如果s[i] &#x3D;&#x3D; s[j]:</p><p><code>dp[i][j] =dp[i+1][j-1]+2 </code></p><p>如果s[i]!&#x3D;s[j]:</p><p><code>dp[i][j] = max(dp[i][j-1],dp[i+1][j])</code></p><p>初始化：</p><p>单个字符就是一个回文序列</p><p>所以<code>dp[i][i] = 1</code></p><ol><li>确定遍历顺序</li></ol><p>从递推公式&#96;&#96;dp[i][j] &#x3D; dp[i + 1][j - 1] + 2 <code>和 </code>dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]) <code>可以看出，</code>dp[i][j]<code>是依赖于</code>dp[i + 1][j - 1] 和 dp[i + 1][j]，&#96;</p><p>也就是从矩阵的角度来说，<code>dp[i][j] </code>下一行的数据。 <strong>所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的</strong>。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正则表达式匹配-字节hard"><a href="#正则表达式匹配-字节hard" class="headerlink" title=" 正则表达式匹配 [字节hard]"></a><a href="https://leetcode.cn/problems/regular-expression-matching/"> 正则表达式匹配</a> [字节hard]</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串</p><blockquote><p>动态规划：<br>定义dp数组及其下标的含义：</p><p><code>dp[i][j]</code>表示<code>s</code>的<code>[0,i-1]</code>的字符串能否被<code>t</code>的<code>[0,j-1]</code>的字符串所匹配。</p><p>确定dp数组的递推公式：</p><p>如果<code>s[i-1] == t[j-1]</code>那么<code>dp[i][j] |= dp[i-1][j-1]</code>表示此时两个字符串的对应下标的字符相等，那么能否被匹配取决于之前的字符串能否被匹配。</p><p>如果<code>s[i-1]!=t[j-1]</code>：</p><ul><li><code>t[j-1] == &#39;.&#39;</code>：这种情况等价于<code>s[i-1] == t[j-1]</code></li><li><code>t[j-1] == &#39;*&#39;</code>: <ul><li>如果<code>t[j-2] != s[j-1] &amp;&amp; t[j-2] != &#39;.&#39;</code>则不匹配但是*号可以让<code>t[j-2]</code>这个出现次数为0，所以此时<code>dp[i][j] = dp[i][j-2]</code></li><li>如果<code>t[j-2] == &#39;.&#39; || t[j-2] == s[j-1]</code>，则认为是匹配的，因为*号可以让<code>t[j-2]</code>出现多次或0次，所以相当于s[i-1]被抵消了，我们需要看<code>s[0,i-2]</code>这部分和<code>t[0,j-1]</code>是不是匹配的。 <code>dp[i][j] = dp[i-1][j]|| dp[i][j-2]</code></li><li>结合上述两个状态 可以将<code>dp[i][j] 先和dp[i][j-2]或，然后再进行判断，如果匹配就和dp[i-1][j]或</code></li></ul></li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j&lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] = i == <span class="hljs-number">0</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">2</span>)&#123;<br>                            dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                            dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>如何区分0-1背包：看每个物品的数量：如果只有一个就是0-1背包</p><p>例题：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>初阶：二维dp数组0-1背包</p><ol><li><p>确定dp数组及其下标的含义</p><p><code>dp[i][j]</code>表示从下标为 0 ~ i 的物品任意取，放进 容量为 j 的背包所得物品的最大价值。</p></li><li><p>确定递推公式</p><p>由两个方向来推这个地推公式</p><ul><li><p>如果不放物品： <code>dp[i][j] = dp[i-1][j]</code>,其实就是物品i的重量大于背包容量j时，物品i无法放入背包，所以背包内的价值和不放物品i的价值一样</p></li><li><p>如果放物品：那么<code>dp[i][j] = dp[i-1][j-weight[i]]+value[i]</code>，此时的最大值等于不放物品i，且背包容量为<code>j-weight[i]</code>时的价值加上物品i 的价值</p></li></ul><p>所以递归公式：<code> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p></li><li><p>初始化</p><p>如果背包重量为0，那么初始化<code>dp[i][0] = 0</code></p><p>在看其他情况。</p><p>状态转移方程 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p><code>dp[0][j]</code> 即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，<code>dp[0][j] </code>应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;&#x3D; weight[0]时，<code>dp[0][j] </code>应该是value[0]，因为背包容量放足够放编号0物品。</p></li><li><p>遍历顺序</p><ul><li><p>先遍历物品</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">// weight数组的大小 就是物品个数<br>for(int i = 1; i &lt; weight.size(); i++) &#123; // 遍历物品<br>    for(int j = 0; j &lt;= bagweight; j++) &#123; // 遍历背包容量<br>        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; <br>        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>先遍历背包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">// weight数组的大小 就是物品个数<br>for(int j = 0; j &lt;= bagweight; j++) &#123; // 遍历背包容量<br>    for(int i = 1; i &lt; weight.size(); i++) &#123; // 遍历物品<br>        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];<br>        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>进阶：一维<code>dp</code>数组（滚动数组）0-1背包</p><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p><p><strong>与其把<code>dp[i - 1]</code>这一层拷贝到<code>dp[i]</code>上，不如只用一个一维数组了</strong>，只用<code>dp[j]</code>（一维数组，也可以理解是一个滚动数组）。</p><p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p>在一维<code>dp</code>数组中，<code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]。</code></p></li><li><p>确定递推公式</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为j - weight[i]的背包所背的最大价值。</p><p><code>dp[j - weight[i]] + value[i] </code>表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：<code>dp[j]</code>）</p><p>此时<code>dp[j]</code>有两个选择，一个是取自己<code>dp[j] </code>相当于 二维<code>dp</code>数组中的<code>dp[i-1][j]，</code>即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]，</code>即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></table></figure></li><li><p>初始化</p><p>再看<code>dp</code>数组的含义：<code>dp[i]</code>表示背包容量为i时的最大价值，故<code>dp[0] = 0</code></p><p>那么其它下标呢？</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让<code>dp</code>数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p></li><li><p>遍历顺序</p><ul><li><p>先遍历物品</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品<br>    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量<br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现二维dp中，遍历背包是从小到达遍历，而一维dp中背包大小是从大到小遍历。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p><p>如果正序遍历</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p><p>因为对于二维<code>dp</code>，<code>dp[i][j]</code>都是通过上一层即<code>dp[i - 1</code>][j]计算而来，本层的<code>dp[i][j]</code>并不会被覆盖！</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p></li><li><p>先遍历背包</p><p>不可以先遍历背包再遍历物品，因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p></li></ul></li></ol><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">分割等和子集</a></h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>本题的要求就是能否找到和为 sum &#x2F; 2 的子集</p><p>而数组中的每一个元素只能用一次，故这道题可以使用0-1背包来解决</p><p>物品就是<code>nums</code>中的元素，背包大小是 sum &#x2F; 2;</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum &#x2F; 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li><li>背包中每一个元素是不可重复放入</li></ul><p>动态规划四部曲：</p><ol><li><p>确定dp数组以及下标的含义</p><p>dp[i]表示和为i时，最大能凑成i的子集总和</p></li><li><p>确定递推公式</p><p><code>dp[j] = max(dp[j],dp[j-nums[i]]+nums[i])</code></p></li><li><p>初始化</p><p>初始化为0即可</p></li><li><p>遍历顺序</p><p>先物品，后背包，背包要倒序遍历</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 0-1背包，背包大小为 sum / 2;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;sum += i;&#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span>== <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagSize</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= nums[i]; j--)&#123;<br>                dp[j] = Math.max(dp[j], dp[j-nums[i]]+nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagSize] == bagSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">最后一块石头的重量 II</a></h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，<br>组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，<br>组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，<br>组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>本题其实就是尽量让石头分成重量相同的两块，相撞之后剩下的石头尽可能小。</p><p>问题转化为：把一堆石头分成两堆,求两堆石头重量差最小值<br>进一步分析：要让差值小,两堆石头的重量都要接近sum&#x2F;2;我们假设两堆分别为A,B,A&lt;sum&#x2F;2,B&gt;sum&#x2F;2,若A更接近sum&#x2F;2,B也相应更接近sum&#x2F;2<br>进一步转化：将一堆stone放进最大容量为sum&#x2F;2的背包,求放进去的石头的最大重量MaxWeight,最终答案即为sum-2*MaxWeight;、</p><p><strong><code>dp[j]</code>表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背<code>dp[j]</code>这么重的石头</strong>。</p><p>其余的和上一题一模一样。</p><p><code>dp[target]</code>里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</p><p><strong>在计算target的时候，target &#x3D; sum &#x2F; 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>那么相撞之后剩下的最小石头重量就是 <code>(sum - dp[target]) - dp[target]。</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 0-1背包</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> weight:stones)&#123;<br>            sum+=weight;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagSize</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= stones[i]; j--)&#123;<br>                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[bagSize] - dp[bagSize];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/description/">目标和</a></h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>问题可以转化为：加法总和减去减法总和等于target——<code>x - (sum - x) = target -&gt; x = (target  + sum ) / 2</code></p><p>和0-1背包联系上就是：把背包容量为x的背包装满有几种方法。</p><p>为什么是0-1背包呢？因为<code>nums</code>中每一个数只能用一次。</p><p>然而和之前做的背包问题不同的是：之前的是求容量为x的背包，最多能装多少。<strong>现在是装满容量为x的背包有几种方法，变成一个组合问题。</strong></p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[j]</code>表示填满容量i的背包有<code>dp[j]</code>种方法。</p></li><li><p>确定递推方程</p><p>如何推出<code>dp[j]</code>呢？</p><p>不考虑<code>nums[i]</code>的情况下，填满容量为<code>j-nums[i]</code>的背包，有<code>dp[j-nums[i]]</code>种方法。</p><p>如果考虑<code>nums[i]</code>的情况下，凑成<code>dp[j]</code>有<code>dp[j-nums[i]]</code>种方法。是不是两种情况都一样呢？不是的</p><p>举例：<code>dp[5]</code>的情况下：</p><ul><li>如果有一个1（<code>nums[i]</code>)，那么凑成容量为5的背包的方法就是等于凑成容量为j - <code>nums[i]</code> &#x3D; 5 -1 &#x3D; 4 的方法。</li><li>如果有一个2（<code>nums[i]</code>)，那么凑成容量为5的背包的方法就是等于凑成容量为j - <code>nums[i]</code> &#x3D; 5 -2 &#x3D; 3 的方法。</li><li>如果有一个3（<code>nums[i]</code>)，那么凑成容量为5的背包的方法就是等于凑成容量为j - <code>nums[i]</code> &#x3D; 5 -3 &#x3D; 2 的方法。</li><li>如果有一个4（<code>nums[i]</code>)，那么凑成容量为5的背包的方法就是等于凑成容量为j - <code>nums[i]</code> &#x3D; 5 -4 &#x3D; 1 的方法。</li><li>如果有一个5（<code>nums[i]</code>)，那么凑成容量为5的背包的方法就是等于凑成容量为j - <code>nums[i]</code> &#x3D; 5 -5 &#x3D; 0 的方法。</li></ul><p>那么凑成<code>dp[5]</code>到底有多少种方法呢，就是把上面的情况累加起来</p><p><code>dp[j] += dp[j- nums[i]]</code>;</p><p><strong>这个公式在完全背包中也会出现</strong></p></li><li><p>初始化</p><p>装满背包容量为0的背包有几种方法，其实就是一种——不装物品</p><p>所以初始化<code>dp[0] = 0</code></p></li><li><p>确定遍历顺序</p><p>一维<code>dp</code>：先遍历物品，再倒序遍历背包。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(Math.abs(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bagSize</span> <span class="hljs-operator">=</span> (target + sum ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= nums[i]; j--)&#123;<br>                dp[j] += dp[j-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">一和零</a></h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;111001&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 &#123;<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>&#125; 和 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; 。&#123;<span class="hljs-string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>不要把这道题当成多重背包，因为<code>strs</code>中每个字符串只能用一次，所以这还是一个0-1背包，只不过背包的维度是二维的。</p><ol><li><p>确定<code>dp</code>数组以及其下标的含义</p><p><code>dp[i][j]</code>表示最多有i个0，j个1的<code>strs</code>的最大子集长度为<code>dp[i][j]</code>。</p></li><li><p>确定递推公式</p><p><code>dp[i][j] </code>可以由前一个<code>strs</code>里的字符串推导出来，<code>strs</code>里的字符串有<code>zeroNum</code>个0，<code>oneNum</code>个1。</p><p><code>dp[i][j] </code>就可以是 <code>dp[i - zeroNum][j - oneNum] + 1</code>。</p><p>然后我们在遍历的过程中，取<code>dp[i][j]</code>的最大值。</p><p>所以递推公式：<code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code></p></li><li><p>初始化</p><p>初始化为0即可</p></li><li><p>确定遍历顺序</p><p>外层物品（每个字符串的0个数和1个数），内层背包（二维的背包），</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(String str: strs)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">zeroNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, oneNum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str.toCharArray())&#123;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    zeroNum++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    oneNum++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m ; i &gt;= zeroNum; i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= oneNum; j--)&#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i-zeroNum][j-oneNum]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="盈利计划"><a href="#盈利计划" class="headerlink" title="盈利计划"></a><a href="https://leetcode.cn/problems/profitable-schemes/description/">盈利计划</a></h3><p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p><p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]<br>输出：2<br>解释：至少产生<span class="hljs-number"> 3 </span>的利润，该集团可以完成工作<span class="hljs-number"> 0 </span>和工作<span class="hljs-number"> 1 </span>，或仅完成工作<span class="hljs-number"> 1 </span>。<br>总的来说，有两种计划。<br></code></pre></td></tr></table></figure><blockquote><p>这同样是一道多维的0-1背包问题：本题与经典背包问题非常相似。两者不同点在于经典背包问题只有一种容量限制，而本题却有两种限制：集团员工人数上限 n，以及工作产生的利润下限 minProfit。</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i][j]</code>表示使用员工不超过i时，工作产生的利润至少为<code>j</code>时的计划数。</p></li><li><p>确定递推公式</p><p><code>dp[j][k] = dp[j][k] + dp[j-group[i]][max(0,k-profit[i])]</code></p><p>怎么理解这个递推公式呢，可以结合目标和这道题来理解。当使用员工不超过j，产生利润为k时，如果目前的项目需要group[i]个人，并且产生利润为profit[i]时那么，凑成<code>dp[j][k]</code>的方案个数等于凑成<code>dp[j-group[i]][max(0,k-profit[i])]</code></p><p>这个<code>max(0,k-profit[i])</code>就是说，如果当前所需最小利润小于profit[i]的话，那么只需要之前的方案能产生0利润即可。</p></li><li><p>初始化</p><p><code>dp[i][0]</code>&#x3D; 1 </p></li><li><p>遍历顺序</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][minProfit+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> group.length,mod =(<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> group[i-<span class="hljs-number">1</span>], earn = profit[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j&gt;= member;j--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> minProfit ; k&gt;= <span class="hljs-number">0</span>; k--)&#123;<br>                    dp[j][k] = (dp[j][k] + dp[j-member][Math.max(<span class="hljs-number">0</span>, k-earn)]) % mod;<br>                &#125;<br>            &#125;         <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>我们看看0-1背包中遍历顺序：因为每个物品只能放一次，所以我们对背包的遍历是倒序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而完全背包中，背包的遍历顺序是正序的，因为每个物品可以放入多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>并且完全背包中先遍历物品和先遍历背包都是可以的。</strong></p><p>至于选择什么遍历顺序，这个要根据题目意思来判断。</p><ul><li>组合数：先遍历物品，再遍历背包</li><li>排列数：先遍历背包，再遍历物品</li></ul><h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-2/description/">零钱兑换 II</a></h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>这是一道经典的完全背包问题。这道题是求凑成amount的硬币的<strong>组合数</strong></p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i]</code>表示凑成金额为i的硬币组合数为<code>dp[i]</code></p></li><li><p>确定递推公式</p><p>和目标和这道题一样，如果凑成<code>dp[j]</code>，如果你有一枚硬币<code>coins[i]</code>那么你就只需要<code>dp[j-coins[i]]</code>种方法。</p><p>所以递推公式就是：<code>dp[j] += dp[j-coins[i]]</code></p></li><li><p>初始化</p><p><code>dp[0] = 1</code></p></li><li><p>遍历顺序</p><p>之前讲过，如果是求组合数，那么遍历顺序就是先遍历物品，再遍历背包。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 先物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; coins.length; i++)&#123;<br>            <span class="hljs-comment">// 再背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++)&#123;<br>                dp[j] += dp[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/description/">组合总和 Ⅳ</a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>完全背包问题</p><p>虽然题目说的是求组合数，但是实际上是求排列数，因为题目说顺序不同的序列视为不同的组合。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 先遍历背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= target; i++)&#123;<br>            <span class="hljs-comment">// 再遍历物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j  &lt; nums.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>( i &gt;= nums[j])&#123;<br>                    dp[i] += dp[i-nums[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/description/">零钱兑换</a></h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>经典的完全背包问题：</p><ol><li><p>确定<code>dp</code>数组及其下标的含义</p><p><code>dp[i]</code>表示凑成金额i的最少硬币数。</p></li><li><p>确定递推公式</p><p>为了得到金钱j，只有一个来源：金钱 j - coins[i] + coins[i];</p><p>而凑成金额j - coins[i]的最少个数为<code>dp[j-coins[i]]</code></p><p>所以<code>dp[j]</code>要取所有<code>dp[j-coins[i]]</code>里最少的再加上1.</p><p>故递归公式：<code>dp[j] = min(dp[j-coins[i]]+1, dp[j])</code></p></li><li><p>初始化</p><p><code>dp[0]</code>从意义上就知道要初始化为0.</p><p>但是其余的下标对应的值，应该初始化为最大值。</p></li><li><p>遍历顺序</p><p>先物品和先背包都可以</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  i&lt;dp.length; i++)&#123;<br>            dp[i] = Integer.MAX_VALUE;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; coins.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> coins[i]; j &lt;= amount; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j-coins[i] ] != Integer.MAX_VALUE)&#123;<br>                    dp[j] = Math.min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全平方数-字节medium"><a href="#完全平方数-字节medium" class="headerlink" title="完全平方数 [字节medium]"></a><a href="https://leetcode.cn/problems/perfect-squares/description/">完全平方数 </a>[字节medium]</h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure><blockquote><p>这道题和上一题零钱兑换很像。</p><p>背包容量是n ，物品是完全平方数，可以使用很多次，所以是完全背包。</p><p><code>dp[j]</code>表示和为j的完全平方数的最少数量。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i] = Integer.MAX_VALUE;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j*j &lt;= i; j++) &#123;<br>                dp[i] = Math.min(dp[i - j * j] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/description/">单词拆分</a></h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure><blockquote><p>这道题也是一道完全背包</p><p>背包就是字符串s，物品就是wordDict.</p><ol><li><p>确定dp数组以及下标的含义</p><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p></li><li><p>确定递推公式</p><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if ([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j] 是true) 那么 dp[i] &#x3D; true。</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// s[0,i-1]是否能呗wordDict划分</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)))&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包递推公式"><a href="#背包递推公式" class="headerlink" title="背包递推公式"></a>背包递推公式</h2><p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">动态规划：416.分割等和子集(opens new window)</a></li><li><a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li></ul><p>问装满背包有几种方法：dp[j] +&#x3D; dp[j - nums[i]] ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和(opens new window)</a></li><li><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li><li><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li><li><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li></ul><p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">动态规划：474.一和零(opens new window)</a></li></ul><p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322.零钱兑换(opens new window)</a></li><li><a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></li></ul><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>            x = <span class="hljs-number">1</span> / x;<br>            n = -n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pow(x,n);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x , <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span> ) == <span class="hljs-number">1</span>)&#123;<br>                res *= x;<br>            &#125;<br>            x*=x;<br>            n = n /<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> k)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((k &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) ans += a;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a += a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1～n-整数中-1-出现的次数-字节hard"><a href="#1～n-整数中-1-出现的次数-字节hard" class="headerlink" title="1～n 整数中 1 出现的次数 [字节hard]"></a><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数</a> [字节hard]</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><blockquote><p>思路就是将1~n的个位，十位，百位等的1出现的次数相加即可。</p><p>用height , low 分别记录高低位的数字，cur记录当前位的数字。digit记录位数——个位，十位这些。</p><ul><li>如果当前位的数字cur&#x3D;0，那么1的次数和高位有关：<code>cur= height * digit</code></li><li>如果当前位数字cur &#x3D; 1，那么1的次数 ： <code>cur = height * dighit + low + 1</code></li><li>如果当前位数字cur !&#x3D; 1 &amp;&amp; cur !&#x3D; 0 ， 那么1的次数：<code>cur = height * digit + digit</code></li></ul><p>初始化：</p><p><code>heigh = n / 10, cur = n % 10 , low = 0 ,digit = 1</code></p><p>迭代：</p><p><code>low += cur *dight, cur = height % 10,height /= 10 </code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>) res += high * digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>) res += high * digit + low + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> res += (high + <span class="hljs-number">1</span>) * digit;<br>            low += cur * digit;<br>            cur = high % <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="用-Rand7-实现-Rand10-字节medium"><a href="#用-Rand7-实现-Rand10-字节medium" class="headerlink" title="用 Rand7() 实现 Rand10() [字节medium]"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">用 Rand7() 实现 Rand10()</a> [字节medium]</h3><p>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</p><p>你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p><p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</p><blockquote><p>一个事实 (randX() - 1)*Y + randY() 可以等概率的生成[1, X * Y]范围的随机数</p><p>首先rand7() - 1得到的集合是：{0,1,2,3,4,5,6}</p><p>然后7*rand7()-1得到的集合A是：{0,7,14,21,28,35,42}</p><p>rand7()得到的集合B是：{1,2,3,4,5,6,7}</p><p>然后这两个集合是独立事件故：<code>P(A)*P(B) = 1/49*</code>故满足等概率。j</p><p>假如我们只取[1,10]的数值返回的话，那么我们的效率就会很低，因为<code>rand7()+(rand7()-1)*7</code>生产的数是[1,49]我们相当于拒绝了39个数，这导致效率非常低。</p><p>拒绝采样的数越少，那么效率就越高。</p><p>我们可以利用[1,40]的数来得到[1,10]的数。</p><p>详细见：<a href="https://leetcode.cn/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/">https://leetcode.cn/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/</a></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SolBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rand10</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> rand7() + <span class="hljs-number">7</span>*(rand7()-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">40</span>)&#123;<br>            num = rand7() + <span class="hljs-number">7</span>*(rand7()-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+num%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共前缀-字节easy"><a href="#最长公共前缀-字节easy" class="headerlink" title="最长公共前缀 [字节easy]"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">最长公共前缀</a> [字节easy]</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>横向比较：</p><p>取出字符串数组的第一个作为开始的前缀，然后分别对每个字符串进行比较，截取最短的前缀。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs.length &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i&lt; strs.length; i++)&#123;<br>            prefix = commonPreFix(prefix,strs[i]);<br>            <span class="hljs-keyword">if</span>(prefix.length() == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonPreFix</span><span class="hljs-params">(String prefix,String str)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(prefix.length(),str.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag &lt; len &amp;&amp; prefix.charAt(flag) == str.charAt(flag))&#123;<br>            flag++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">0</span>,flag);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>纵向比较</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs.length &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prefix.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> prefix.charAt(i);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == strs[j].length() || strs[j].charAt(i) != c)&#123;<br>                    <span class="hljs-keyword">return</span> prefix.substring(<span class="hljs-number">0</span>,i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分治</p><img src="https://assets.leetcode-cn.com/solution-static/14/14_fig3.png" alt="fig3" style="zoom: 33%;" /></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs.length &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> longestCommon(strs,<span class="hljs-number">0</span>,strs.length-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommon</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> strs[left];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">leftLong</span> <span class="hljs-operator">=</span> longestCommon(strs,left,mid);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rightLong</span> <span class="hljs-operator">=</span> longestCommon(strs,mid+<span class="hljs-number">1</span>,right);<br>            <span class="hljs-keyword">return</span> commonPreFix(leftLong,rightLong);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">commonPreFix</span><span class="hljs-params">(String prefix,String str)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(prefix.length(),str.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag &lt; len &amp;&amp; prefix.charAt(flag) == str.charAt(flag))&#123;<br>            flag++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">0</span>,flag);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a><a href="https://leetcode.cn/problems/non-decreasing-array/description/">非递减数列</a></h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [4,2,3]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>遍历数组模拟，如果<code>nums[i-1] &lt;= nums[i]</code>则符合题意，跳过此情况</p><p>如果<code>nums[i-1] &gt; nums[i]</code>则需要进行改变，那么是改变<code>nums[i]</code>还是改变<code>nums[i-1]</code>是需要分情况讨论的</p><p>讨论取决于<code>nums[i-2]</code>和<code>nums[i]</code>的值:</p><ul><li><code>nums[i-2] &gt; nums[i]</code>那么就要修改<code>nums[i]的值为nums[i-1]</code> eg: [4,2,3]</li><li><code>nums[i-2] &lt;=nums[i]</code>那么就修改 <code>nums[i-1]</code>的值为<code>nums[i]</code> eg: [-1,4,2,3]</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPossibility</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n &amp;&amp; cnt &lt; <span class="hljs-number">2</span> ;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i-<span class="hljs-number">1</span>] &lt;= nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(i-<span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i-<span class="hljs-number">2</span>] &gt; nums[i])&#123;<br>                nums[i] = nums[i-<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums[i-<span class="hljs-number">1</span>] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Z-字形变换-字节medium"><a href="#Z-字形变换-字节medium" class="headerlink" title="Z 字形变换 [字节medium]"></a><a href="https://leetcode.cn/problems/zigzag-conversion/description/">Z 字形变换</a> [字节medium]</h3><p>​将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">P</span>   <span class="hljs-selector-tag">A</span>   H   N<br><span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">P</span> L S <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">I</span> G<br>Y   <span class="hljs-selector-tag">I</span>   R<br></code></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p><blockquote><p>字符串s是以Z字形为顺序存储的字符串，目标是按行打印</p><p>顺序遍历字符串时，每个字符在Z字形中对应的行索引是从0到numRows-1，再从numRows-1到0.</p><p>所以解决方案就是模拟这个行索引的变化。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-keyword">if</span>(numRows &lt; <span class="hljs-number">2</span> )<span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        List&lt;StringBuilder&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            list.get(i).append(c);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == numRows-<span class="hljs-number">1</span>) flag = - flag;<br>            i+=flag;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(StringBuilder sb : list)&#123;<br>            ans.append(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除排序数组重复项，并保留K个重复值："><a href="#删除排序数组重复项，并保留K个重复值：" class="headerlink" title="删除排序数组重复项，并保留K个重复值："></a>删除排序数组重复项，并保留K个重复值：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> process(nums,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[]nums, <span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            <span class="hljs-keyword">if</span>(idx &lt; k || nums[idx-k]!=x) nums[idx++] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> idx;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">移除元素</a></h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != val)&#123;<br>                nums[slow++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> , j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">while</span>(j &lt; n )&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[i];<br>                nums[i] =temp;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="移掉-K-位数字-字节medium"><a href="#移掉-K-位数字-字节medium" class="headerlink" title="移掉 K 位数字 [字节medium]"></a><a href="https://leetcode.cn/problems/remove-k-digits/">移掉 K 位数字</a> [字节medium]</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p>示例 1 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;1432219&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;1219&quot;</span><br>解释：移除掉三个数字 <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, 和 <span class="hljs-number">2</span> 形成一个新的最小的数字 <span class="hljs-number">1219</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>给定一个长度为 n 的数字序列  $$  [D_0D_1D_2D_3\ldots D_{n-1}]，$$ 从左到右找到第一个位置，使得$Di&lt;Di−1$,并且删除$Di-1$。如果没有则删除最后一个数即可。</p><p>所以很适合使用单调栈来应用</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> k)</span> &#123;<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> num.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> num.charAt(i);<br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span> &amp;&amp; digit &lt; deque.peekLast())&#123;<br>                deque.pollLast();<br>                k--;<br>            &#125;<br>            deque.offerLast(digit);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; k; i++)&#123;<br>            deque.pollLast();<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">leadingZero</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-keyword">if</span>(leadingZero &amp;&amp; digit == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            leadingZero = <span class="hljs-literal">false</span>;<br>            res.append(digit);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.length() == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;0&quot;</span>:res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本计算器-字节hard"><a href="#基本计算器-字节hard" class="headerlink" title="基本计算器 [字节hard]"></a><a href="https://leetcode.cn/problems/basic-calculator/">基本计算器</a> [字节hard]</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><blockquote><p>思路：</p><p>双栈：一个数值栈<code>nums</code>，一个操作数栈<code>ops</code></p><p>先把表达式s里的空格都去掉。</p><p>然后遍历s，对遇到的字符做判断：</p><ul><li><code>(</code>入栈，等待与之匹配的<code>)</code></li><li><code>)</code>,使用现有的<code>nums</code>和<code>ops</code>进行计算，直到遇到第一个左括号为止，计算结果放在<code>nums</code></li><li>数字：从当前为止开始往后取，直到取到整个整数出来，放入<code>nums</code></li><li>操作数：需要将操作放入<code>ops</code>，<strong>放入之前需要把栈内可以算的都算了。</strong>使用现有的<code>nums</code>和<code>ops</code>计算直到没有操作数或者遇到左括号。</li></ul><p>一些细节：</p><p>由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 nums 添加一个 0<br>为防止 () 内出现的首个字符为运算符，将所有的空格去掉，并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 存放所有的数字</span><br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为了防止第一个数为负数，先往 nums 加个 0</span><br>        nums.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将所有的空格去掉</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 存放所有的操作，包括 +/-</span><br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cs[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.addLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 计算到最近一个左括号为止</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty()) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.peekLast();<br>                    <span class="hljs-keyword">if</span> (op != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        calc(nums, ops);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        ops.pollLast();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isNum(c)) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span><br>                    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(cs[j++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    nums.addLast(u);<br>                    i = j - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        nums.addLast(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span><br>                    <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) calc(nums, ops);<br>                    ops.addLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!ops.isEmpty()) calc(nums, ops);<br>        <span class="hljs-keyword">return</span> nums.peekLast();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pollLast(), a = nums.pollLast();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pollLast();<br>        nums.addLast(op == <span class="hljs-string">&#x27;+&#x27;</span> ? a + b : a - b);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果还有其它运算符，需要先用一个map记录优先级，然后区别就是在<code>calc()</code>以及新操作入栈时，对优先级进行判断，只有栈内优先级高的才能计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ops.peekLast();<br><span class="hljs-keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;<br>calc(nums, ops);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h3 id="字符串解码-字节hard"><a href="#字符串解码-字节hard" class="headerlink" title=" 字符串解码 [字节hard]"></a><a href="https://leetcode.cn/problems/decode-string/"> 字符串解码</a> [字节hard]</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3[a2[c]]&quot;</span><br>输出：<span class="hljs-string">&quot;accaccacc&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>双栈辅助：一个栈存储乘数，一个栈存储字符串。</p><ul><li>遇到<code>[</code>，则把乘数<code>mult</code>入栈，然后把字符串<code>res</code>入栈并且二者都归0。</li><li>遇到<code>]</code>，则是到了<code>[]</code>的尽头，需要构建当前的字符串:<code>res = last_res + temp</code>。这个temp表示<code>[]</code>中的重复字符串，然后需要把<code>x[]</code>中的乘数x取出来，这个x在遇到<code>[</code>时已经入栈了，所以要取出栈顶的元素就是x。然后<code>[]</code>中的字符串，就是当前的res保存。</li><li>遇到数字：更新mult</li><li>遇到字母：加入res</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        LinkedList&lt;Integer&gt; st_mult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        LinkedList&lt;String&gt; st_res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mult</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>           <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>               st_mult.addLast(mult);<br>               st_res.addLast(res.toString());<br>               mult = <span class="hljs-number">0</span>;<br>               res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> st_mult.pollLast();<br>               <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; times; j++) temp.append(res.toString());<br>               res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(st_res.pollLast() + temp.toString());<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isNum(cs[i]))&#123;<br>               mult = mult*<span class="hljs-number">10</span> +(<span class="hljs-type">int</span>)(cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               res.append(cs[i]);<br>           &#125;<br>       &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">return</span> Character.isDigit(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口最大值-字节hard"><a href="#滑动窗口最大值-字节hard" class="headerlink" title="滑动窗口最大值 [字节hard]"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a> [字节hard]</h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>示例：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><blockquote><p>单调队列。</p><p>维护一个单调递减的队列。因此队首的元素一直都是最大值。</p><p>然后还需要对队首元素判断是否在窗口中，如果不在窗口中需要进行弹出。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Deque&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!que.isEmpty() &amp;&amp; nums[i] &gt;= nums[que.peekLast()])&#123;<br>                que.pollLast();<br>            &#125;<br>            que.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-k+<span class="hljs-number">1</span>];<br>        res[<span class="hljs-number">0</span>] = nums[que.peekFirst()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!que.isEmpty() &amp;&amp; nums[i] &gt;= nums[que.peekLast()])&#123;<br>                que.pollLast();<br>            &#125;<br>            que.offerLast(i);<br>            <span class="hljs-keyword">while</span>(que.peekFirst() &lt;= i-k)&#123;<br>                que.pollFirst();<br>            &#125;<br>            res[i-k+<span class="hljs-number">1</span>] = nums[que.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="每日温度-字节medium"><a href="#每日温度-字节medium" class="headerlink" title=" 每日温度 [字节medium]"></a><a href="https://leetcode.cn/problems/daily-temperatures/"> 每日温度</a> [字节medium]</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></table></figure><blockquote><p>单调栈：</p><p>维护一个温度单调递减的栈，栈中存的是下标。如果遇到温度大于栈顶的元素，就把栈顶弹出，更新答案。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()]  &lt; temperatures[i])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> i - idx;<br>                res[idx] = days;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="柱状图中最大的矩形-字节hard"><a href="#柱状图中最大的矩形-字节hard" class="headerlink" title="柱状图中最大的矩形 [字节hard]"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a> [字节hard]</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例一</strong>：</p><p><img src="/leetcode_recod.assets/histogram.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><ol><li><p>暴力：</p><p>如何求矩形的面积呢？面积&#x3D;底×高，我们可以固定高度，然后扩散求底边长度，就是从该节点i开始向左和向右找到 <strong>第一个严格小于该节点高度的下标left, right</strong>然后算出底边长度即可。这个思想是这道题的关键。</p><p>只不过暴力法中最坏情况可能会遍历两边数组。时间复杂度为O(n*n)会超时</p></li></ol></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempHeight</span> <span class="hljs-operator">=</span> heights[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span>(left - <span class="hljs-number">1</span>&gt;= <span class="hljs-number">0</span> &amp;&amp; heights[left-<span class="hljs-number">1</span>] &gt;= heights[i])&#123;<br>                left--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right+<span class="hljs-number">1</span> &lt; n &amp;&amp; heights[right+<span class="hljs-number">1</span>] &gt;= heights[i])&#123;<br>                right++;<br>            &#125;<br>            ans = Math.max(ans,(right-left+<span class="hljs-number">1</span>)*tempHeight);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据这个思想我们可以进行优化，我们可以用一个单调栈来很快地实现找到某个节点的向左，向右的第一个小于他的下标left,right。这个单调栈是单调递增栈。</p><p>单次遍历时，如果当前节点的高度小于栈顶节点的高度，那么以栈顶节点的高度为高的矩形面积就可以确定。然后为了让所有节点的高度都能出栈，我们需要使用哨兵机制，在高度数组两端各加一个高度为0的元素。</p><p>底边长的算法就是：<strong>i-st.peek()-1</strong></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] newHeights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++ )&#123;<br>            newHeights[i] = heights[i-<span class="hljs-number">1</span>];<br>        &#125; <br>        n = newHeights.length;<br>        LinkedList&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.isEmpty() &amp;&amp; newHeights[st.peek()] &gt; newHeights[i])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> st.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> i - st.peek()-<span class="hljs-number">1</span>;<br>                ans = Math.max(ans,len*newHeights[cur]);<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大矩形-字节hard"><a href="#最大矩形-字节hard" class="headerlink" title="最大矩形 [字节hard]"></a><a href="https://leetcode.cn/problems/maximal-rectangle/">最大矩形</a> [字节hard]</h3><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例</strong></p><p><img src="/leetcode_recod.assets/maximal.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>柱状图中最大的矩形：</p><p><img src="/leetcode_recod.assets/aabb1b287134cf950aa80526806ef4025e3920d57d237c0369ed34fae83e2690-image.png" alt="image.png"></p><p>这道题就是遍历每一层，求它的高度数组height[]然后传给上一题的函数即可。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> m= matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;j &lt; n ;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    heights[j]+=<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    heights[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            ans = Math.max(ans, largestRectangleArea(heights));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] newHeights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            newHeights[i]=heights[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        LinkedList&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        n = newHeights.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!st.isEmpty() &amp;&amp; newHeights[st.peek()] &gt; newHeights[i])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> st.pop();<br>                ans = Math.max(ans,(i-st.peek()-<span class="hljs-number">1</span>)*newHeights[cur]);<br>            &#125;<br>            st.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大正方形-字节medium"><a href="#最大正方形-字节medium" class="headerlink" title="最大正方形 [字节medium]"></a><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a> [字节medium]</h3><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><p><strong>示例：</strong></p><p><img src="/leetcode_recod.assets/max1grid.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>动态规划：</p><p>定义<code>dp[i][j]</code>表示以(i,j)作为右下角，且只包含1的正方形的边长的最大值。</p><p>如何得到<code>dp[i][j]</code>呢？</p><p><code>dp[i][j]</code>可以从它的左侧，上侧以及左上侧来确定。</p><p><code>dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code></p><p>初始化：<code>if(i == 0 || j == 0 ) dp[i][j] =   1</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalSquare</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] ==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>|| j== <span class="hljs-number">0</span>)&#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] =Math.min(dp[i-<span class="hljs-number">1</span>][j],Math.min(dp[i][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]))+<span class="hljs-number">1</span>;<br>                    &#125;<br>                    ans = Math.max(dp[i][j],ans);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans*ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长有效括号-字节hard"><a href="#最长有效括号-字节hard" class="headerlink" title="最长有效括号 [字节hard]"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a> [字节hard]</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p> <strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>栈+数组</p><p>用一个额外的数组来记录匹配的括号，如果该下标的括号是匹配的则为0，求最长的连续0序列长度。</p><p>先用一个栈来模拟匹配的过程。如果遇到不匹配的括号下标则将该下标的匹配数组置为1。</p><p>匹配过程结束后，如果栈非空，则意味着这些括号也是未匹配的。都置为1。</p><p>然后统计。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                st.push(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(st.isEmpty())&#123;<br>                    dp[i] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    st.pop();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st.pop();<br>            dp[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i] == <span class="hljs-number">1</span>)&#123;<br>                len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            len++;<br>            max = Math.max(max,len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>动态规划：</p><p>定义<code>dp[i]</code>表示以i位置结尾，形成的有效括号子串的最长长度。</p><p>很明显。如果<code>s[i]</code>为左括号，则<code>dp[i] = 0</code></p><p>如果<code>s[i]</code>为右括号：我们要进行区分：</p><p>我们首先获取之前一个位置的有效括号长度为preLen&#x3D;dp[i-1]</p><p>如果这个长度的前一个位置<code>pre = i- preLen - 1</code>是左括号，那么<code>dp[i] = dp[i-1]+2</code></p><p>注意，此时需要再看看<code>pre</code>的前一个位置是不是有效括号子串，如果是，就把该位置的长度也合并过来。</p><p>注意，只需要看这一次就好，因为之前的也会有这个过程。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preLen</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> i - preLen - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(pre &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(pre) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(pre-<span class="hljs-number">1</span>&gt;= <span class="hljs-number">0</span>)&#123;<br>                        dp[i] += dp[pre-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>                ans = Math.max(ans,dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常数级空间优化（最优解）</p><p>正向逆向结合法：用两个变量记录左右括号的个数</p><p>正向遍历：（左括号希望匹配右括号）如果遇到左括号则，左括号数+1，如果遇到右括号则右括号数+1，前提是遇到右括号时，右括号数小于左括号数。</p><p>如果左括号数和右括号数相等，更新答案为这两个数之和与答案的最大值。如果右括号数大于左括号，则归0，意味着前面没有一个左括号可以与它匹配。</p><p>逆向遍历：（右括号希望匹配左括号）如果遇到右括号，则右括号数+1，如果遇到左括号且左括号数小于右括号数，则左括号数+1，如果两个数相等，则更新答案为两个数之和与答案的最大值。如果左括号数大于右括号数则归0，意味着后面没有一个右括号可以与它匹配。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;right++;&#125;<br>            <span class="hljs-keyword">if</span>(left == right)&#123;<br>                max = Math.max(max,left+right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right &gt; left ) &#123;left = <span class="hljs-number">0</span>; right = <span class="hljs-number">0</span>;&#125;<br>        &#125;<br>        left = <span class="hljs-number">0</span>; right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;right++;&#125;<br>            <span class="hljs-keyword">if</span>(left == right)&#123;<br>                max = Math.max(max,left+right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(right &lt; left ) &#123;left = <span class="hljs-number">0</span>; right = <span class="hljs-number">0</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接雨水-字节hard"><a href="#接雨水-字节hard" class="headerlink" title="接雨水 [字节hard]"></a><a href="https://leetcode.cn/problems/trapping-rain-water/description/">接雨水</a> [字节hard]</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><blockquote><p>动态规划</p><p>朴素的做法就是对于每个下标，计算这个下标处能接多少水。</p><p>能接多少水取决于，这个下标两边的最大高度的最小值——i左边的最大高度是遍历[0,i]，记录一个最大值，i右边的最大高度是遍历[i+1,n-1]，记录一个最大值，取二者的最小值，然后减去height[i]就是这个地方能够接的雨水量。</p><p>上述朴素的暴力方法时间复杂度为O(n^2)。</p><p>我们可以用两个数组，分别记录下标i左边和右边的最大值。</p><p>定义leftMax[i]表示i左边的高度的最大值, rightMax[i]表示i右边高度的最大值。</p><p>显然：<code>leftMax[i] = max(leftMax[i-1],height[i])</code>;<code>rightMax[i] = max(rightMax[i+1], height[i])</code></p><p>初始化： <code>leftMax[0] = height[0], rightMax[n-1] = height[n-1]</code></p><p>然后再遍历这个高度数组，每个下标i处的接水量 &#x3D; <code>min(leftMax[i],rightMax[i]) - height[i]</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[n-<span class="hljs-number">1</span>] = height[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            leftMax[i] = Math.max(leftMax[i-<span class="hljs-number">1</span>],height[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            rightMax[i] = Math.max(rightMax[i+<span class="hljs-number">1</span>],height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            res += Math.min(leftMax[i],rightMax[i])-height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单调栈</p><p>我们同样可以用一个单调栈来计算接水量。</p><p>我们使用一个单调递减的栈，因为如果高度单调递减那么，这时是无法接水的。</p><p>当栈顶元素小于当前遍历的高度时，我们把栈顶元素弹出，说明栈顶处是一个低洼，可以用来接雨水。</p><p>雨水量是一个长方形：设此时高度的下标为i，栈顶元素为top，栈顶下一个元素的下标为left，那么底边长为：i-left-1高度取<code>min(height[i],height[left]) - height[top]</code></p><p>这是个持续的过程，如果当前高度比height[left]还大，就继续执行上述过程，直到栈为空，我们始终要维持一个单调递减的栈。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peekLast()])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peekLast();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> i - left - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[i], height[left]) - height[top];<br>                res += h * len;<br>            &#125;<br>            stack.offerLast(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>双指针</p><p>在动态规划中我们用了两个数组来存储这些左右的最大值。然而我们其实是可以使用常数级的空间来存储这些最大值。</p><p>即两个柱子同时接雨水，假设两个柱子为i，j。那么就有iLeftMax，iRightMax，jLeftMax，jRightMax</p><p>而 j &gt; i 故 jLeftMax &gt;&#x3D; iLeftMax ； iRightMax &lt;&#x3D; jRightMax</p><p>如果 iLeftMax &gt; jRightMax 那么就有 jLeftMaxt &gt;&#x3D; jRightMax,则j点的接雨水就是 jRightMax - height[j]</p><p>如果 iLeftMax &lt; jRightMax 那么就有 iLeftMax &lt;&#x3D; iRightMax 则i点的接雨水量就是iLeftMax - height[i];</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>       <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            maxLeft = Math.max(maxLeft,height[left]);<br>            maxRight = Math.max(maxRight,height[right]);<br>            <span class="hljs-keyword">if</span>(maxLeft &lt; maxRight)&#123;<br>                count += maxLeft - height[left++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count += maxRight - height[right--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前-K-个高频元素-字节medium"><a href="#前-K-个高频元素-字节medium" class="headerlink" title="前 K 个高频元素 [字节medium]"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a> [字节medium]</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><blockquote><p>思路一：使用小根堆来模拟过程，使用哈希表来统计出现次数</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        HashMap&lt;Integer,Integer&gt; occurrences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)&#123;<br>            occurrences.put(i,occurrences.getOrDefault(i,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1[<span class="hljs-number">1</span>]-o2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 去重</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; count) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[]  res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            res[i++] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>桶排序</p><p>还是用哈希表来统计元素的频数，然后用一个桶，下标是数字的频数，下标对应的值是一个数组，即频数一样的数放到一个桶里。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基于桶排序求解「前 K 个高频元素」</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span><br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(num)) &#123;<br>               map.put(num, map.get(num) + <span class="hljs-number">1</span>);<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(num, <span class="hljs-number">1</span>);<br>             &#125;<br>        &#125;<br>        <span class="hljs-comment">//桶排序</span><br>        <span class="hljs-comment">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span><br>        List&lt;Integer&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[nums.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> key : map.keySet())&#123;<br>            <span class="hljs-comment">// 获取出现的次数作为下标</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span>(list[i] == <span class="hljs-literal">null</span>)&#123;<br>               list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            &#125; <br>            list[i].add(key);<br>        &#125;<br>        <span class="hljs-comment">// 倒序遍历数组获取出现顺序从大到小的排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> &amp;&amp; res.size() &lt; k;i--)&#123;<br>            <span class="hljs-keyword">if</span>(list[i] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            res.addAll(list[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::valueOf).toArray();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="字典树-x2F-前缀树-x2F-Trie"><a href="#字典树-x2F-前缀树-x2F-Trie" class="headerlink" title="字典树&#x2F;前缀树&#x2F;Trie"></a>字典树&#x2F;前缀树&#x2F;Trie</h3><h4 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h4><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]<br><br>解释<br>Trie trie = <span class="hljs-built_in">new</span> Trie();<br>trie.<span class="hljs-keyword">insert</span>(&quot;apple&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">False</span><br>trie.startsWith(&quot;app&quot;); // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">insert</span>(&quot;app&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><blockquote><p>前缀树有两种实现方法：</p><ul><li>朴素的实现方法：一开始就分配好整棵树的空间，并且用数组实现</li><li><code>TrieNode</code>的实现方法: 动态分配空间，自定义一个节点数据结构</li></ul></blockquote><h5 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h5><ul><li>二维数组<code>trie[N][26]</code>来记录单词字符,N一般取<code>1e7</code></li><li>一维数组<code>isEnd[]</code>来记录结尾单词 &#x2F; 用<code>count[]</code>来记录某个格子被使用的次数（被标记为结尾的次数）</li><li>index 变量来记录使用的格子数（给被用到的格子计数）</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>    <span class="hljs-type">int</span>[][] trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N*<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(trie[p][u] == <span class="hljs-number">0</span>) trie[p][u] = ++idx;<br>            p = trie[p][u];<br>        &#125;<br>        count[p]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>  word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(trie[p][u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = trie[p][u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> count[p] != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>  prefix.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> prefix.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(trie[p][u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = trie[p][u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TrieNode树节点实现"><a href="#TrieNode树节点实现" class="headerlink" title="TrieNode树节点实现"></a><code>TrieNode</code>树节点实现</h5><p>随着数据的不断插入，要不断地创建新节点</p><p><code>TrieNode</code>的属性有：</p><ul><li><code>isEnd</code>：是否是最后一个节点</li><li><code>TrieNode[]</code>：当前节点的子节点</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>        <span class="hljs-type">boolean</span> isEnd;<br>        TrieNode[] tns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    TrieNode root ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[idx] == <span class="hljs-literal">null</span>) p.tns[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            p = p.tns[idx];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p.tns[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prefix.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> prefix.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[idx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p.tns[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加与搜索单词-数据结构设计"><a href="#添加与搜索单词-数据结构设计" class="headerlink" title="添加与搜索单词 - 数据结构设计"></a><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/">添加与搜索单词 - 数据结构设计</a></h4><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p><p>实现词典类 <code>WordDictionary</code> ：</p><ul><li><code>WordDictionary()</code> 初始化词典对象</li><li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li><li><code>bool search(word)</code> 如果数据结构中存在字符串与 <code>word</code> 匹配，则返回 <code>true</code> ；否则，返回 <code>false</code> 。<code>word</code> 中可能包含一些 <code>&#39;.&#39;</code> ，每个 <code>.</code> 都可以表示任何一个字母。</li></ul><blockquote><p>思路：</p><p>这道题就是考察字典树的模板题，唯一不同的是，需要根据<code>&#39;.&#39;</code>这个字符来区分情况。</p><p>如果遇到了<code>&#39;.&#39;</code>就要进行遍历搜索，于是很容易想到深度优先搜索</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDictionary</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>        <span class="hljs-type">boolean</span> isEnd;<br>        TrieNode[] tns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    TrieNode root ;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWord</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[idx] == <span class="hljs-literal">null</span>) p.tns[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            p = p.tns[idx];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(word,root,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, TrieNode p, <span class="hljs-type">int</span> idx )</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>s.length();<br>        <span class="hljs-keyword">if</span>(idx == n)&#123;<br>            <span class="hljs-keyword">return</span> p.isEnd;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(idx);<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>                <span class="hljs-comment">// 这里在判断这里深度搜索，否则如果在if体内进行返回dfs，会错过正确答案</span><br>                <span class="hljs-keyword">if</span>(p.tns[i] != <span class="hljs-literal">null</span> &amp;&amp; dfs(s,p.tns[i],idx+<span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> c-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[u] != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> dfs(s,p.tns[u],idx+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单词搜索-II"><a href="#单词搜索-II" class="headerlink" title="单词搜索 II"></a><a href="https://leetcode.cn/problems/word-search-ii/description/">单词搜索 II</a></h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>， <em>返回所有二维网格上的单词</em> 。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>],[<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>]], words = [<span class="hljs-string">&quot;oath&quot;</span>,<span class="hljs-string">&quot;pea&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;rain&quot;</span>]<br>输出：[<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;oath&quot;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>这里使用回溯+前缀树</p><p>这里使用<code>TrieNode</code>的方式建树，不同的是把<code>isEnd</code>换成s，来记录字符串，省去另外记录字符串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>        String   s;<br>        TrieNode[] tns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-type">TrieNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dirs = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWord</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[idx] == <span class="hljs-literal">null</span>) p.tns[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            p = p.tns[idx];<br>        &#125;<br>        p.s = word;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String s : words) addWord(s);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(root.tns[u]!=<span class="hljs-literal">null</span>)&#123;<br>                    vis[i][j] = <span class="hljs-literal">true</span>;<br>                    dfs(board, i, j, root.tns[u]);<br>                    vis[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : set) ans.add(s);<br>        <span class="hljs-keyword">return</span> ans;<br><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j,TrieNode p)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">if</span>(p.s != <span class="hljs-literal">null</span>) set.add(p.s);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir : dirs)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>], dy = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dx &lt; <span class="hljs-number">0</span> || dy &lt; <span class="hljs-number">0</span> || dx &gt;=m || dy &gt;= n ) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(vis[dx][dy]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> board[dx][dy] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.tns[u] != <span class="hljs-literal">null</span>)&#123;<br>                vis[dx][dy] = <span class="hljs-literal">true</span>;<br>                dfs(board, dx, dy, p.tns[u]);<br>                vis[dx][dy] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="词典中最长的单词"><a href="#词典中最长的单词" class="headerlink" title="词典中最长的单词"></a><a href="https://leetcode.cn/problems/longest-word-in-dictionary/description/">词典中最长的单词</a></h4><p> 给出一个字符串数组 <code>words</code> 组成的一本英语词典。返回 <code>words</code> 中最长的一个单词，该单词是由 <code>words</code> 词典中其他单词逐步添加一个字母组成。</p><p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;wo&quot;</span>,<span class="hljs-string">&quot;wor&quot;</span>,<span class="hljs-string">&quot;worl&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>]<br>输出：<span class="hljs-string">&quot;world&quot;</span><br>解释： 单词<span class="hljs-string">&quot;world&quot;</span>可由<span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-string">&quot;wo&quot;</span>, <span class="hljs-string">&quot;wor&quot;</span>, 和 <span class="hljs-string">&quot;worl&quot;</span>逐步添加一个字母组成。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>模拟——我们可以用一个哈希集合来存储words数组，</p><p>根据题目意思，求最长的单词，要求这个单词是由其它单词逐步添加一个字母组成。</p><p>所以用<code>HashSet</code>来方便后续用O(1)的复杂度来判断某个子串是否在数组中。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestWord</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 添加到set中</span><br>        <span class="hljs-keyword">for</span>(String s : words) set.add(s);<br>        <span class="hljs-keyword">for</span>(String s : set)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ans.length();<br>            <span class="hljs-comment">// 如果该字符串小于目前的答案字符串就无效</span><br>            <span class="hljs-keyword">if</span>( n &lt; m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 如果该字符串的字典序大于目前答案的字符串就无效</span><br>            <span class="hljs-keyword">if</span>( n == m &amp;&amp; s.compareTo(ans) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 判断该字符串的子串是否都在words数组中</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; ok ; i++)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">0</span>, i);<br>                <span class="hljs-keyword">if</span>(!set.contains(sub)) ok = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ok) ans = s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用字典树来优化</p><p>上述解法中「枚举某个 <code>words[i]</code> 的所有子串，并判断子串是否在 words 数组中出现」的操作可使用「字典树」来实现。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">30010</span>, M = <span class="hljs-number">26</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] isEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N*M];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(tr[p][u] == <span class="hljs-number">0</span>) tr[p][u] = ++idx;<br>            p = tr[p][u];<br>        &#125;<br>        isEnd[p] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找字符串的所有子串是否在字典树中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)- <span class="hljs-string">&#x27;a&#x27;</span>;<br>            p = tr[p][u];<br>            <span class="hljs-keyword">if</span>(!isEnd[p]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestWord</span><span class="hljs-params">(String[] words)</span> &#123;<br>        Arrays.fill(isEnd, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= idx; i++) Arrays.fill(tr[i], <span class="hljs-number">0</span>);<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(String s : words) add(s);<br>        <span class="hljs-keyword">for</span>(String s: words)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ans.length();<br>            <span class="hljs-keyword">if</span>(n &lt; m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(n == m &amp;&amp; s.compareTo(ans) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(query(s)) ans = s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="键值映射"><a href="#键值映射" class="headerlink" title="键值映射"></a><a href="https://leetcode.cn/problems/map-sum-pairs/description/">键值映射</a></h4><p>设计一个 map ，满足以下几点:</p><ul><li>字符串表示键，整数表示值</li><li>返回具有前缀等于给定字符串的键的值的总和</li></ul><p>实现一个 <code>MapSum</code> 类：</p><ul><li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li><li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对 <code>key-value</code> 将被替代成新的键值对。</li><li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;MapSum&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;sum&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;sum&quot;</span>]<br>[[], [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">&quot;ap&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&quot;ap&quot;</span>]]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>]<br><br>解释：<br>MapSum mapSum = <span class="hljs-keyword">new</span> MapSum();<br>mapSum.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>);  <br>mapSum.<span class="hljs-built_in">sum</span>(<span class="hljs-string">&quot;ap&quot;</span>);           <span class="hljs-comment">// 返回 3 (apple = 3)</span><br>mapSum.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;app&quot;</span>, <span class="hljs-number">2</span>);    <br>mapSum.<span class="hljs-built_in">sum</span>(<span class="hljs-string">&quot;ap&quot;</span>);           <span class="hljs-comment">// 返回 5 (apple + app = 3 + 2 = 5)</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>从需要实现 存储字符串（映射关系） 并且检索某个字符串的前缀的总和来看，这是需要字典树以及深度优先搜索的题目</p><p>与模板字典树不同的是，我们通过存储哈希值来替换<code>isEnd</code>数组。添加的过程就最后这里不同，其它一致。</p><p>对于<code>sum()</code>函数，我们先搜索字符串前缀，如果这个字符串前缀不存在在字典树中，就返回0，否则就深度优先以这个字符串为开头的所有字符串，并且加上他们的哈希值</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] tr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5000</span>][<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5000</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapSum</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> key.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> key.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(tr[p][u] == <span class="hljs-number">0</span>) tr[p][u] = ++idx;<br>            p = tr[p][u];<br>        &#125;<br>        <span class="hljs-comment">// 用哈希值来替换isEnd</span><br>        hash[p] = val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> hash[p];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(tr[p][i] != <span class="hljs-number">0</span>) ans += dfs(tr[p][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prefix.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> prefix.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">// 如果没有对应前缀则返回0；</span><br>            <span class="hljs-keyword">if</span>(tr[p][u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            p = tr[p][u];<br>        &#125;<br>        <span class="hljs-comment">// 搜索所有以该前缀开头的字符串</span><br>        <span class="hljs-keyword">return</span> dfs(p);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="字典序的第K小数字-字节hard-O-logn-logn"><a href="#字典序的第K小数字-字节hard-O-logn-logn" class="headerlink" title="字典序的第K小数字 [字节hard] O(logn * logn)"></a><a href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/description/">字典序的第K小数字</a> [字节hard] O(logn * logn)</h4><p>给定整数 <code>n</code> 和 <code>k</code>，返回 <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 13, k = 2</span><br><span class="hljs-section">输出: 10</span><br><span class="hljs-section">解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</span><br></code></pre></td></tr></table></figure><blockquote><p>计数模拟</p><p>寻找字典序第k小的数，我们将该操作分成两个部分：【确定前缀】 和【从某个前缀开始找目标值】</p><p>假定我们存在某个函数 int getCnt(int x, int limit)，该函数实现了统计范围 <code>[1, limit] </code>内以 x 为前缀的数的个数。</p><p>有了该函数后，我们可以从最小前缀1开始枚举，假设现在枚举到x，根据cnt &#x3D; getCnt(x,n)：</p><p>如果cnt &lt;&#x3D; k : 说明以x为前缀的数组均可以跳过，让x自增。k减去cnt</p><p>如果cnt &gt; k：说明以x为前缀的数组包含了目标值，且前缀为x，让x*10，k-1跳过x身，含义为从下一个字典序比x大的前缀中招目标值。</p><p>如何统计以x为前缀且小于n 的数呢</p><p>我们可以用两个数来记录x为前缀的每一层的最大值和最小值：first， last</p><p>一开始first &#x3D; last &#x3D; x表示从这个节点开始。</p><p>然后保证first 小于等于 n</p><p>每一层的数目怎么计算呢？</p><p>如果last &lt; n 说明n大于这一层最大的数，那么小于n的计数就是：last - first + 1</p><p>如果last &gt; n 说明n所在的范围是[first,last]之间那么这一层有多少个小于n的数呢：n - first + 1。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 从1开始，因为1是字典序里最小的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 如果k=1就不进入下面的循环。之间返回1</span><br>        k--;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 以curr为前缀有多少个数小于n</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> getCnt(curr, n);<br>            <span class="hljs-comment">// 如果cnt &lt; k说明这些数都可以跳过，不在第k个</span><br>            <span class="hljs-keyword">if</span> (cnt &lt;= k) &#123;<br>                <span class="hljs-comment">// 需要往兄弟节点搜索</span><br>                curr++;<br>                k -= cnt;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果cnt &gt; k 说明以curr前缀的数包含第k个，进入子节点搜索</span><br>                curr *= <span class="hljs-number">10</span>;<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCnt</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> x; <span class="hljs-comment">// 第i层的最左的端点（最小的数）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> x; <span class="hljs-comment">// 第i层的最右的断点（最大的数）</span><br>        <span class="hljs-keyword">while</span> (first &lt;= n) &#123;<br>            <span class="hljs-comment">// 如果last &lt; n这一层有 ： last -first  +1 个节点</span><br>            <span class="hljs-comment">// 取 min(last, n);</span><br>            cnt += Math.min(last, n) - first + <span class="hljs-number">1</span>;<br>            first = first *  <span class="hljs-number">10</span>;<br>            last  = last * <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从前序与中序遍历序列构造二叉树-字节medium"><a href="#从前序与中序遍历序列构造二叉树-字节medium" class="headerlink" title=" 从前序与中序遍历序列构造二叉树 [字节medium]"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"> 从前序与中序遍历序列构造二叉树</a> [字节medium]</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>  示例 1:</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: preorder = <span class="hljs-string">[3,9,20,15,7]</span>, inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>输出: <span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><blockquote><p>递归求解：</p><p>前序遍历的第一个元素的值就是根节点的值。</p><p>根据这个值构造根节点</p><p>然后遍历中序数组，找到一个值等于根节点的值，这个值的左边就是左子树，这个值的右边就是右子树。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span> || n ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == preorder[<span class="hljs-number">0</span>])&#123;<br>                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(inorder,<span class="hljs-number">0</span>,i));<br>                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="hljs-number">1</span>,m),Arrays.copyOfRange(inorder,i+<span class="hljs-number">1</span>,n));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>迭代：</p><p>前序遍历中相邻的两个节点u和v，他们的关系有两种可能：</p><ul><li>v是u的左节点</li><li>u没有左节点，并且v是u某个祖先或者u的右节点。</li></ul><p>我们用一个栈来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。只有栈中的节点才会有可能连接一个右节点。除此之外我们再用一个<code>index</code>指针指向中序遍历中的某个位置，初始化为0。index节点表示当前节点不断往左走的终点。</p><p>栈用前序遍历的首个元素初始化入栈，然后遍历前序遍历数组。</p><p>如果栈顶元素不等于index所指的元素，那么现在遍历的元素就是栈顶元素的左节点。【假设现在遍历的元素不是栈顶元素的左节点的话，那么中序遍历（左根右）中index所指的元素应该等于栈顶元素。】将现在遍历的元素入栈。</p><p>如果栈顶元素等于index所指的元素。那么现在遍历的元素就是栈中某个节点的右节点。<strong>如何确定是哪个节点是现在遍历的节点的父节点呢？</strong> 我们知道栈中元素的右节点还没出现过，<strong>因此栈中元素出现的顺序（从底到顶）和中序遍历中出现的顺序是相反的</strong>。因此如果index所对应的节点刚好等于栈顶所对应的节点，那么我们可以弹出栈顶，并且index+1。知道index对应的节点不等于栈顶节点。我们弹出的最后一个值x，就是现在遍历节点的父节点。因为现在遍历节点会出现在x和x在栈中的下一个节点之间。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">if</span>(preorder == <span class="hljs-literal">null</span> || preorder.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;n ;i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-keyword">if</span>(node.val != inorder[index])&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[i]);<br>                node.left = left;<br>                stack.push(left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[index])&#123;<br>                    node=stack.pop();<br>                    index++;<br>                &#125;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[i]);<br>                node.right = right;<br>                stack.push(right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的右视图-字节medium"><a href="#二叉树的右视图-字节medium" class="headerlink" title="二叉树的右视图  [字节medium]"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a>  [字节medium]</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>层序遍历，将每一层的最后一个节点加入答案即可。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i == size - <span class="hljs-number">1</span>)&#123;<br>                    ans.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>深度优先搜索</p><p>用栈来模拟，然后用一个哈希表对应（层数和右节点）</p><p>遍历时，如果该层数的哈希表没有对应的节点，就把该节点加入。</p><p>因为深度优先搜索时，先加入左节点，再加入右节点，每次都是先拿出右节点来判断，故如果该层数的哈希表没有对应的节点，就是第一个右节点。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 层数 - 右节点值</span><br>        Map&lt;Integer,Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDepth</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        Stack&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;Integer&gt; depths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        nodes.push(root);<br>        depths.push(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!nodes.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodes.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> depths.pop();<br>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">null</span>)&#123;<br>                maxDepth = Math.max(maxDepth,depth);<br>                <span class="hljs-comment">// 先访问右节点的，如果对应层数没有节点值，则表示这个元素就是这一层的右节点。</span><br>                <span class="hljs-keyword">if</span>(mp.get(depth) == <span class="hljs-literal">null</span>)&#123;<br>                    mp.put(depth,node.val);<br>                &#125;<br>                nodes.push(node.left);<br>                nodes.push(node.right);<br>              <span class="hljs-comment">// 层数要加1，然后每次加入两个节点对应。</span><br>                depths.push(depth+<span class="hljs-number">1</span>);<br>                depths.push(depth+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt;=maxDepth; i++)&#123;<br>            res.add(mp.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例：</strong></p><p><img src="/leetcode_recod.assets/binarytree.png" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>找出从根节点到p和q节点的路径。</p><p>然后比较路径上最后一个相等的节点就是公共祖先。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode root,TreeNode node,List&lt;TreeNode&gt; path)</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag || root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.add(root);<br>        <span class="hljs-keyword">if</span>(root == node)&#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        getPath(root.left, node, path);<br>        getPath(root.right,node,path);<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        List&lt;TreeNode&gt; pPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        getPath(root,p,pPath);<br>        flag = <span class="hljs-literal">false</span>;<br>        List&lt;TreeNode&gt; qPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        getPath(root,q,qPath);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ,j = <span class="hljs-number">0</span> ; i &lt; pPath.size() &amp;&amp; j &lt; qPath.size(); i++,j++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> pPath.get(i);<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> qPath.get(j);<br>            <span class="hljs-keyword">if</span>(node1 == node2)&#123;<br>                ans = node1;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>bfs遍历，并用哈希表记录每一个节点的父节点。</p><p>遍历完之后用哈希集合记录其中一个节点的父节点集合。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;TreeNode,TreeNode&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    HashSet&lt;TreeNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);<br>        parent.put(root,<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                parent.put(node.left,node);<br>                queue.offer(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                parent.put(node.right,node);<br>                queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>            set.add(p);<br>            p = parent.get(p);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!set.contains(q))&#123;<br>            q = parent.get(q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></h3><p><strong>示例</strong></p><p><img src="/leetcode_recod.assets/serdeser.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>用层序遍历来序列化，用特殊的节点来记录空结点。</p><p>反序列化时：也是层次遍历，先用队列记录根节点，然后从序列化的字符串中取出该结点的左右节点。</p><p>为什么能这样呢？因为我们序列化时，确保了每个根节点都有两个子节点（如果子节点为空则用特殊节点替代）。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">TreeNode</span> <span class="hljs-variable">emptyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(INF);<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>            sb.append(node.val+<span class="hljs-string">&quot;#&quot;</span>);<br>            <span class="hljs-keyword">if</span>(node != emptyNode)&#123;<br>                que.offer(node.left != <span class="hljs-literal">null</span> ? node.left : emptyNode);<br>                que.offer(node.right != <span class="hljs-literal">null</span> ? node.right: emptyNode);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(data.length() &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        String[] ss = data.split(<span class="hljs-string">&quot;#&quot;</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(ss[<span class="hljs-number">0</span>]));<br>        Deque&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; ss.length-<span class="hljs-number">1</span>; i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[i]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[i+<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>( a != INF)&#123;<br>                poll.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(a);<br>                que.offer(poll.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(b!=INF)&#123;<br>                poll.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(b);<br>                que.offer(poll.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉搜索树转双向链表"><a href="#二叉搜索树转双向链表" class="headerlink" title="二叉搜索树转双向链表"></a>二叉搜索树转双向链表</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">Convert</span><span class="hljs-params">(TreeNode pRootOfTree)</span> &#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Convert(pRootOfTree.left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">null</span>)&#123;<br>            head = pRootOfTree;<br>            pre = pRootOfTree;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pre.right = pRootOfTree;<br>            pRootOfTree.left = pre;<br>            pre = pRootOfTree;<br>        &#125;<br>        Convert(pRootOfTree.right);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树展开成链表"><a href="#二叉树展开成链表" class="headerlink" title="二叉树展开成链表"></a>二叉树展开成链表</h3><p><img src="/leetcode_recod.assets/flaten.jpg" alt="img"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root.left;<br>            <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">while</span>(p.right!=<span class="hljs-literal">null</span>) p = p.right;<br>                p.right = root.right;<br>                root.right = root.left;<br>                root.left = <span class="hljs-literal">null</span>;<br>            &#125;<br>            root = root.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">return</span> (A != <span class="hljs-literal">null</span> &amp;&amp; B != <span class="hljs-literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中<strong>是否存在</strong> 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例：</p><img src="../../../../SophomoreⅡ/算法/我要去字节.assets/pathsum1.jpg" alt="img" style="zoom: 50%;" /><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-literal">true</span><br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>遍历求解</p><p>题目只需要找到一条符合条件的路径即可。 我们可以深度优先搜索看有没有这个路径。</p><p>函数<code>dfs(root,sum)</code>用来搜索，如果找到了一个节点的值等于sum则返回true</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>        &#125;<br>        dfs(root,targetSum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(sum == root.val)&#123;<br>                ans = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfs(root.left,sum - root.val);<br>        dfs(root.right,sum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出<strong>所有</strong> 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例：</p><img src="../../../../SophomoreⅡ/算法/我要去字节.assets/pathsumii1.jpg" alt="img" style="zoom:50%;" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,null,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], targetSum = <span class="hljs-number">22</span><br>输出：<span class="hljs-string">[[5,4,11,2],[5,8,4,5]]</span><br><br></code></pre></td></tr></table></figure><blockquote><p>回溯</p><p>要保证在该节点回溯时，删除的是该结点，而不是回溯到父节点才去删除它的子节点。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        dfs(root,targetSum);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        temp.offerLast(root.val);<br>        sum -= root.val;<br>        <span class="hljs-keyword">if</span>(root.left ==<span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>)&#123;     <br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(temp));<br>            <span class="hljs-comment">// 注意这里不能return</span><br>        &#125;<br>        dfs(root.left,sum);<br>        dfs(root.right,sum);<br>        temp.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>广度优先遍历整颗树：</p><p>一个队列用来遍历，一个队列用来添加路径和。再用一个哈希表来记录节点的父节点。</p></blockquote><p>​代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    HashMap&lt;TreeNode,TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; queueSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);<br>        queueSum.offer(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rec</span> <span class="hljs-operator">=</span> queueSum.poll() + node.val;<br>            <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(rec == targetSum)&#123;<br>                    getPath(node);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    map.put(node.left,node);<br>                    queue.offer(node.left);<br>                    queueSum.offer(rec);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    map.put(node.right,node);<br>                    queue.offer(node.right);<br>                    queueSum.offer(rec);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-literal">null</span>)&#123;<br>            temp.add(node.val);<br>            node = map.get(node);<br>        &#125;<br>        Collections.reverse(temp);<br>        ans.add(temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>示例：</p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img" style="zoom:50%;" /><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">3</span><br>解释：和等于 <span class="hljs-number">8</span> 的路径有 <span class="hljs-number">3</span> 条，如图所示。<br><br></code></pre></td></tr></table></figure><blockquote><p>双重递归：</p><p>首先从根节点出发，看看满足条件的路径有几条。然后再从左右子节点出发，看看满足条件的路径有几条。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> getSum(root, targetSum);<br>        ret += pathSum(root.left, targetSum);<br>        ret += pathSum(root.right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> sum)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">if</span>(sum == val)&#123;<br>            ret++; <br>        &#125;<br>        ret += getSum(root.left, sum - val);<br>        ret += getSum(root.right, sum - val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀和：</p><p>上一种解法简答来说就是计算每个节点出发的路径和等于targetSum的有几种。本题有个严格的约束：<strong>路径只能往下</strong></p><p>因此如果我们转换一下，统计以每个节点为「路径结尾」的合法数量的话，配合原本就是「从上往下」进行的数的遍历（最完整的路径必然是从原始根节点到当前节点的唯一路径），相当于只需要在完整路径中找到有多少个节点到当前节点的路径总和为 <code>targetSum。</code></p><p>于是这个树上问题彻底转换一维问题：求解从原始起点（根节点）到当前节点 bb 的路径中，有多少节点 a 满足 <code>[a...b]=targetSum</code>，由于从原始起点（根节点）到当前节点的路径唯一，因此这其实是一个「一维前缀和」问题。</p><p>我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> t ;<br>    HashMap&lt;Long,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        t = targetSum;<br>        map.put(<span class="hljs-number">0L</span>,<span class="hljs-number">1</span>);<br>        dfs(root,root.val);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> prefixSum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(prefixSum - t)) ans += map.get(prefixSum - t);<br>        map.put(prefixSum,map.getOrDefault(prefixSum,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)  dfs(root.left, prefixSum+root.left.val);<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>) dfs(root.right, prefixSum+root.right.val);<br>        map.put(prefixSum,map.getOrDefault(prefixSum,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">课程表</a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><blockquote><p>拓扑排序</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        <span class="hljs-type">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            adjacency.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-comment">// Get the indegree and adjacency of every course.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] cp : prerequisites) &#123;<br>            indegrees[cp[<span class="hljs-number">0</span>]]++;<br>            adjacency.get(cp[<span class="hljs-number">1</span>]).add(cp[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// Get all the courses with the indegree of 0.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>) queue.add(i);<br>        <span class="hljs-comment">// BFS TopSort.</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> queue.poll();<br>            numCourses--;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cur : adjacency.get(pre))<br>                <span class="hljs-keyword">if</span>(--indegrees[cur] == <span class="hljs-number">0</span>) queue.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a><a href="https://leetcode.cn/problems/print-in-order/">按序打印</a></h3><p>给你一个类：</p><p>public class Foo {<br>  public void first() { print(“first”); }<br>  public void second() { print(“second”); }<br>  public void third() { print(“third”); }<br>}<br>三个不同的线程 A、B、C 将会共用一个 Foo 实例。</p><p>线程 A 将会调用 first() 方法<br>线程 B 将会调用 second() 方法<br>线程 C 将会调用 third() 方法<br>请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</p><blockquote><p>信号量</p><p>Semaphore：acquire()会阻塞进程，直到对应的信号量的值大于0。</p><p>Semaphore：release()会增加信号量的值（+1）</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-comment">// printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br>        printFirst.run();<br>        two.release();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        two.acquire();<br>        <span class="hljs-comment">// printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br>        printSecond.run();<br>        third.release();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        third.acquire();<br>        <span class="hljs-comment">// printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br>        printThird.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个线程交替打印1——100"><a href="#两个线程交替打印1——100" class="headerlink" title="两个线程交替打印1——100"></a>两个线程交替打印1——100</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i+=<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        thread1.acquire();<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;: &quot;</span>+i);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">finally</span>&#123;<br>                        thread2.release();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i+=<span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        thread2.acquire();<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;: &quot;</span>+i);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-comment">// TODO Auto-generated catch block</span><br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">finally</span>&#123;<br>                        thread1.release();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable1).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable2).start();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><h3 id="7-1-为表达式设计优先级"><a href="#7-1-为表达式设计优先级" class="headerlink" title="7.1 为表达式设计优先级"></a>7.1 为表达式设计优先级</h3><p>给你一个由数字和运算符组成的字符串 <code>expression</code> ，按不同优先级组合数字和运算符，计算并返回<strong>所有可能组合</strong>的结果。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 <code>104</code> 。</p><p>示例：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：expression = &quot;2*3<span class="hljs-string">-4</span>*5&quot;<br>输出：[<span class="hljs-string">-34</span>,<span class="hljs-string">-14</span>,<span class="hljs-string">-10</span>,<span class="hljs-string">-10</span>,10]<br>解释：<br>(2*(3-(4*5))) = <span class="hljs-string">-34</span> <br>((2*3)-(4*5)) = <span class="hljs-string">-14</span> <br>((2*(3<span class="hljs-string">-4</span>))*5) = <span class="hljs-string">-10</span> <br>(2*((3<span class="hljs-string">-4</span>)*5)) = <span class="hljs-string">-10</span> <br>(((2*3)<span class="hljs-string">-4</span>)*5) = 10<br></code></pre></td></tr></table></figure><p>思路：</p><p>看到题目找出<code>找出所有可能组合的结果</code>就很容易想道<code>dfs</code>暴力搜索。并且题目要求的数据规模是expression长度小于20。故<code>dfs</code>是可行的。</p><p>但是如何设计这个<code>dfs函数</code>呢？</p><p>求表达式的题目中，应该要想到 <strong>分治法</strong> 因为一个表达式是由一些表达式组成 如：<code>&quot;3+1+2-3*5&quot;其实是由很多个小表达式如3+1,3*5这样组成</code>。即由「小表达式」的结果推导出「大表达式」的结果</p><p>那么可以设计<code>dfs(int l, int r)</code>,表示在[l,r]内的这个表达式字符串所得到可能组合的结果。</p><p>当表达式没有任何运算符时，给定的expression[l…r]就是一个数值。</p><p>遍历这个字符串expression，当expression[i]为符号的时候就分治，分成运算符左边<code>dfs(l,i-1)</code>的结果组合，和右边<code>dfs(i+1,r)</code>的结果组合。</p><p>为什么这样就能得到所有结果呢？以expression[i]为分割点，要计算表达式的结果，其实就是分成两步，第一步是求表达式左边的所有结果，共有n种，第二步是求表达式右边的所有结果，共有m种，那么表达式的所有结果就是<code>n*m</code>种——乘法原理。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">Class Solution&#123;<br><span class="hljs-type">char</span>[] ch;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">diffWaysToCompute</span><span class="hljs-params">(String s)</span>&#123;<br>        ch = s.toCharArray();<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,ch.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt;= r; i++)&#123;<br>            <span class="hljs-comment">// 遍历字符串，直到遇见运算符，视为分割点</span><br>            <span class="hljs-keyword">if</span>(ch[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; ch[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 求左右两边子表达式的结果</span><br>            List&lt;Integer&gt; ll = dfs(l,i-<span class="hljs-number">1</span>);<br>            List&lt;Integer&gt; rr = dfs(i+<span class="hljs-number">1</span>,r);<br>            <span class="hljs-comment">// 乘法原理求组合结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : ll)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b : rr)&#123;<br>                    <span class="hljs-comment">// 当前结果</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">// 根据运算符不同来计算</span><br>                    <span class="hljs-keyword">if</span>(ch[i] == <span class="hljs-string">&#x27;+&#x27;</span>) cur = a+b;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch[i] ==<span class="hljs-string">&#x27;-&#x27;</span>) cur = a-b;<br>                    <span class="hljs-keyword">else</span> cur = a*b;<br>                    ans.add(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 当表达式只剩下数字时，把数字加入结果中(递归头)</span><br>        <span class="hljs-keyword">if</span>(ans.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l ; i &lt;= r ; i++) cur = cur*<span class="hljs-number">10</span> + (ch[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            ans.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-最低加油次数"><a href="#7-2-最低加油次数" class="headerlink" title="7.2 最低加油次数"></a>7.2 最低加油次数</h3><p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code> 英里处。</p><p>沿途有加油站，每个 <code>station[i]</code> 代表一个加油站，它位于出发位置东面 <code>station[i][0]</code> 英里处，并且有 <code>station[i][1]</code> 升汽油。</p><p>假设汽车油箱的容量是无限的，其中最初有 <code>startFuel</code> 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p><p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p><p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p><p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p><p>示例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br>输出：2<br>解释：<br>我们出发时有<span class="hljs-number"> 10 </span>升燃料。<br>我们开车来到距起点<span class="hljs-number"> 10 </span>英里处的加油站，消耗<span class="hljs-number"> 10 </span>升燃料。将汽油从<span class="hljs-number"> 0 </span>升加到<span class="hljs-number"> 60 </span>升。<br>然后，我们从<span class="hljs-number"> 10 </span>英里处的加油站开到<span class="hljs-number"> 60 </span>英里处的加油站（消耗<span class="hljs-number"> 50 </span>升燃料），<br>并将汽油从<span class="hljs-number"> 10 </span>升加到<span class="hljs-number"> 50 </span>升。然后我们开车抵达目的地。<br>我们沿途在1两个加油站停靠，所以返回<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>思路1：优先队列+贪心</p><p>贪心：每次都加油量最多的油，就能保证加油的次数最少。</p><p>用一个优先队列来维护能加的最大油量。当油量不足到达下一个加油站时就加最大的油量。</p><p>油量足以到达下一个加油站时，就把当前加油站的油量加入优先队列中（大根堆）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRefuelStops</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startFuel, <span class="hljs-type">int</span>[][] stations)</span> &#123;<br>    <span class="hljs-comment">// 维护一个大根堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;(o2-o1));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stations.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 遍历变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最终结果</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> startFuel; <span class="hljs-comment">// 当前油量</span><br>    <span class="hljs-comment">// 这里最好使用while循环来限定题目的最终目标：到达target</span><br>    <span class="hljs-keyword">while</span>(cur &lt; target)&#123;<br>        <span class="hljs-comment">// 可以到达下一个加油站，不需要加油</span><br>        <span class="hljs-keyword">if</span>(i &lt; n &amp;&amp; cur &gt;= stations[i][<span class="hljs-number">0</span>])&#123;<br>            pq.add(stations[i][<span class="hljs-number">1</span>]);<br>            i++；<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 到达不了下一个加油站</span><br>            <span class="hljs-keyword">if</span>(!pq.isEmpty())&#123;<br>                cur += pq.poll();<br>                res++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 加了所有油都到达不了下一个加油站或者target</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：动态规划</p><p>这道题虽然一看就知道和贪心有关，既然贪心能解决，动态规划也能解决,当然效率就不如贪心好。</p><p>我们可以维护一个dp数组<code>dp[i],表示加i次油能到达的最远距离</code>。</p><p>初始化：不加油的时候：<code>dp[0] = startFuel</code></p><p>状态转移：每到达第i个加油站时，车已经加了j次油 <code>1&lt;= j &lt;= i</code>当<code>dp[j]&gt;station[i][0]</code>时才能到达该加油站进行加第j+1次油。<code>dp[j+1] = max(dp[j+1],dp[j]+station[i][1])</code>。每到一次加油站，都要更新前j次加油的情况。这样才能确保每次加油能到达的最远距离。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRefuelStops</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startFuel, <span class="hljs-type">int</span>[][] stations)</span> &#123;<br>    <span class="hljs-comment">// 有n个加油站</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stations.length;<br>    <span class="hljs-comment">// dp[i] 表示加i次油能到达的最远距离</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 初始化dp[0]</span><br>    dp[<span class="hljs-number">0</span>] = startFuel;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-keyword">if</span>(dp[j] &gt;= stations[i][<span class="hljs-number">0</span>])&#123;<br>                dp[j+<span class="hljs-number">1</span>] = Math.max(dp[j+<span class="hljs-number">1</span>],dp[j]+stations[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(dp[i] &gt;= target)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-下一个最大值Ⅲ"><a href="#7-3-下一个最大值Ⅲ" class="headerlink" title="7.3 下一个最大值Ⅲ"></a>7.3 下一个最大值Ⅲ</h3><p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code> 中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> 。</p><p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> 。</p><p>示例1</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">12</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>示例2</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：就是寻找字典序的下一个排列。力扣31 <a href="https://leetcode.cn/problems/next-permutation/">https://leetcode.cn/problems/next-permutation/</a></p><p>《算法设计与分析》这本书 P 112 有讲如何找出所有字典序排列</p><p>思想就是从后往前遍历，找到第一个小于右边的数<code>a_i</code>然后在<code>a_i+1&gt;a_i+2&gt;....&gt;a_n</code>中找第一个大于<code>a_i</code>的值，交换两个位置，再把<code>i+1</code>之后的数翻转试其递增。如：362541，从后往前的第一个小于右边的数是2，在后面的序列中，4是第一个大于2的值，交换2和4，再把i+1之后的数值翻转得到：364125。</p><p>为什么要这样做呢，我们要求下一个字典序的排列，即值越小越好，那么我们希望找一个较小值，这个较小值尽量地靠右，找一个较大值，这个较大值尽量地靠左。这样两个交换才能产生一个较小但是比原来大的值，再把交换位置后原本递减的序列翻转，试其递增，得到的就是最小的较大数。</p><p>本题不同的就是把数值换成一个字符数组就行了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = String.valueOf(n).toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> ch.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; ch[r] &gt;= ch[r + <span class="hljs-number">1</span>]) &#123;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> ch.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; ch[r] &gt;= ch[j]) &#123;<br>            j--;<br>        &#125;<br>        swap(ch, r, j);<br>        reverse(ch, r + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Long.parseLong(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch));<br>        <span class="hljs-keyword">return</span> ans &gt; Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : (<span class="hljs-type">int</span>) ans;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            swap(nums, i, j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">// 时间复杂度：O(N)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br></code></pre></td></tr></table></figure><h3 id="7-4-最小绝对差"><a href="#7-4-最小绝对差" class="headerlink" title="7.4 最小绝对差"></a>7.4 <a href="https://leetcode.cn/problems/minimum-absolute-difference/description/">最小绝对差</a></h3><p>给你个整数数组 <code>arr</code>，其中每个元素都 <strong>不相同</strong>。</p><p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[4,2,1,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>]</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>排序+模拟</p><p>对数组排序后，遍历数组，当遇到绝对差值小于目前绝对差值时，将列表清空，将最新的绝对差值对添加进去，如果相等也添加，如果大于则不管。</p><p>O(n log(n) )</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=1200 lang=java</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [1200] 最小绝对差</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">minimumAbsDifference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Arrays.sort(arr);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.abs(arr[<span class="hljs-number">1</span>] - arr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;  <br>            <span class="hljs-keyword">if</span> (Math.abs(arr[j] - arr[i]) &lt; min) &#123;<br>                ans.clear();<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(arr[i], arr[j])));<br>                min = Math.abs(arr[j] - arr[i]);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Math.abs(arr[j] - arr[i]) == min) &#123;<br>                ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(arr[i], arr[j])));<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// @lc code=end</span><br></code></pre></td></tr></table></figure><h3 id="7-5-我的日程安排表-I"><a href="#7-5-我的日程安排表-I" class="headerlink" title="7.5 我的日程安排表 I"></a>7.5 <a href="https://leetcode.cn/problems/my-calendar-i/description/">我的日程安排表 I</a></h3><p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的日程安排不会造成 <strong>重复预订</strong> ，则可以存储这个新的日程安排。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 <strong>重复预订</strong> 。</p><p>日程可以用一对整数 <code>start</code> 和 <code>end</code> 表示，这里的时间是半开区间，即 <code>[start, end)</code>, 实数 <code>x</code> 的范围为，  <code>start &lt;= x &lt; end</code> 。</p><p>实现 <code>MyCalendar</code> 类：</p><ul><li><code>MyCalendar()</code> 初始化日历对象。</li><li><code>boolean book(int start, int end)</code> 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code> 。否则，返回 <code>false</code> 并且不要将该日程安排添加到日历中。</li><li><strong>提示：</strong><ul><li><code>0 &lt;= start &lt; end &lt;= 109</code></li><li>每个测试用例，调用 <code>book</code> 方法的次数最多不超过 <code>1000</code> 次。</li></ul></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 示例：">输入：<br>[&quot;MyCalendar&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]<br>[[], [10, 20], [15, 25], [20, 30]]<br>输出：<br>[null, true, false, true]<br><br>解释：<br>MyCalendar myCalendar = new MyCalendar();<br>myCalendar.book(10, 20); // return True<br>myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。<br>myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。<br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>暴力：<br>对于每个进来的[start,end]遍历已预订的日程安排</p><p>如果start &gt; <code>pre[1]</code> || end &lt; <code>pre[0]</code>则符合目标，不管，如果不满足直接返回false</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=729 lang=java</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [729] 我的日程安排表 I</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; records ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendar</span><span class="hljs-params">()</span> &#123;<br>        records = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        end--;<br>        <span class="hljs-keyword">if</span>(records.isEmpty())&#123;<br>            records.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(start,end)));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;       <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; records.size();i++)&#123;<br>            List&lt;Integer&gt; books = records.get(i);<br>            <span class="hljs-keyword">if</span>(start &gt; books.get(<span class="hljs-number">1</span>) || end &lt; books.get(<span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br>        records.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(start,end)));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>二分查找</p><p>如果我们按时间顺序维护日程安排，则可以通过二分查找日程安排的情况来检查新日程安排是否可以预订，若可以预订则在排序结构中更新插入日程安排。</p><ul><li>用一个可保持元素排序，且插入快的数据结构来完成，可以用 **<code>TreeSet</code>**，对于[start, end] 先找到第一个大于end的数组<code>[left1,right1]</code>,然后再找这个数组前一位数<code>[left2,right2]</code>，如果满足<code>right2 &lt;= start &lt;= end &lt;= left1</code>则可以插入，否则无法插入</li></ul></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=729 lang=java</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [729] 我的日程安排表 I</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeSet&lt;<span class="hljs-type">int</span>[]&gt; booked;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendar</span><span class="hljs-params">()</span> &#123;<br>        booked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span>(booked.isEmpty())&#123;<br>            booked.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start,end&#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] tmp = &#123;end,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] arr = booked.ceiling(tmp);<br>        <span class="hljs-type">int</span>[] pre = arr==<span class="hljs-literal">null</span>?booked.last():booked.lower(arr);<br>        <span class="hljs-keyword">if</span>(arr == booked.first() || pre[<span class="hljs-number">1</span>] &lt;= start)&#123;<br>            booked.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start,end&#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-7-单词替换（字典树）"><a href="#7-7-单词替换（字典树）" class="headerlink" title="7.7 单词替换（字典树）"></a>7.7 <a href="https://leetcode.cn/problems/replace-words/description/">单词替换</a>（字典树）</h3><p>在英语中，我们有一个叫做 <code>词根</code>(root) 的概念，可以词根<strong>后面</strong>添加其他一些词组成另一个较长的单词——我们称这个词为 <code>继承词</code>(successor)。例如，词根<code>an</code>，跟随着单词 <code>other</code>(其他)，可以形成新的单词 <code>another</code>(另一个)。</p><p>现在，给定一个由许多<strong>词根</strong>组成的词典 <code>dictionary</code> 和一个用空格分隔单词形成的句子 <code>sentence</code>。你需要将句子中的所有<strong>继承词</strong>用<strong>词根</strong>替换掉。如果<strong>继承词</strong>有许多可以形成它的<strong>词根</strong>，则用<strong>最短</strong>的词根替换它。</p><p>你需要输出替换之后的句子。</p><p><strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：dictionary = [<span class="hljs-comment">&quot;cat&quot;</span>,<span class="hljs-comment">&quot;bat&quot;</span>,<span class="hljs-comment">&quot;rat&quot;</span>], sentence = <span class="hljs-comment">&quot;the cattle was rattled by the battery&quot;</span><br>输出：<span class="hljs-comment">&quot;the cat was rat by the bat&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">dictionary</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>], sentence = <span class="hljs-string">&quot;aadsfasf absbs bbab cadsfafs&quot;</span><br>输出：<span class="hljs-string">&quot;a a b c&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>思路：</p><p>哈希集合：把词根加入到哈希集合中，遍历句子中的所有词，遍历这个词的子串，如果这个词的子串刚好包含了某个词根（满足最短的词根）则将该词替换为该子串。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String string:dictionary)&#123;<br>            set.add(string);<br>        &#125;<br>        String[] words = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word.length(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(dictionary.contains(word.substring(<span class="hljs-number">0</span>,j+<span class="hljs-number">1</span>)))&#123;<br>                    words[i] = word.substring(<span class="hljs-number">0</span>, j+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀树Trie</p><p>前缀树用来存储词根，然后遍历句子中的每个词语，如果匹配到词根则直接返回该词根。</p><p>这里前缀树使用一个二维数组来实现。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">27</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] trie = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] isEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[M*N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx ;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(trie[p][u] == <span class="hljs-number">0</span>)&#123;<br>                trie[p][u] = ++idx;<br>            &#125;<br>            p = trie[p][u];<br>        &#125;<br>        isEnd[p] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">search</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(trie[p][u] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isEnd[trie[p][u]]) <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>);<br>            p = trie[p][u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceWords</span><span class="hljs-params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= idx; i++)&#123;<br>            Arrays.fill(trie[i], <span class="hljs-number">0</span>);<br>            isEnd[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(String d :dictionary) add(d);<br>        <span class="hljs-keyword">for</span>(String s : sentence.split(<span class="hljs-string">&quot; &quot;</span>)) sb.append(search(s)).append(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>,sb.length()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-8-玩筹码"><a href="#7-8-玩筹码" class="headerlink" title="7.8 玩筹码"></a>7.8 <a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/description/">玩筹码</a></h3><p>有 <code>n</code> 个筹码。第 <code>i</code> 个筹码的位置是 <code>position[i]</code> 。</p><p>我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 <code>i</code> 个筹码的位置从 <code>position[i]</code> 改变为:</p><ul><li><code>position[i] + 2</code> 或 <code>position[i] - 2</code> ，此时 <code>cost = 0</code></li><li><code>position[i] + 1</code> 或 <code>position[i] - 1</code> ，此时 <code>cost = 1</code></li></ul><p>返回将所有筹码移动到同一位置上所需要的 <em>最小代价</em> 。</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：position = <span class="hljs-string">[2,2,2,3,3]</span><br>输出：<span class="hljs-number">2</span><br>解释：我们可以把位置<span class="hljs-number">3</span>的两个筹码移到位置<span class="hljs-number">2</span>。每一步的成本为<span class="hljs-number">1</span>。总成本= <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：position = [1,2,3]<br>输出：1<br><span class="hljs-section">解释：第一步:将位置3的筹码移动到位置1，成本为0。</span><br><span class="hljs-section">第二步:将位置2的筹码移动到位置1，成本= 1。</span><br>总成本是1。<br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>枚举：</p><p>枚举每一个位置，以它为最终的所有筹码放置的位置，然后算移动筹码的代近。</p><p>枚举时，如果是偶数的位置，成本为0，否则为1</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostToMoveChips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] position)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> position.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i  &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> position[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> position[j];<br>                cur += Math.abs(a-b) % <span class="hljs-number">2</span>;<br>            &#125;<br>            ans = Math.min(cur, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路：<br>实际上，以为奇偶相同的位置，移动的话成本为0，其实最终移动的成本来自于奇偶位置不同的筹码移动产生。</p><p>故只需要枚举奇数位数的个数，以及偶数位置的个数来即可。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostToMoveChips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] position)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, even = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : position)&#123;<br>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                even++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                odd++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(odd, even);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-9-最长的斐波那契子序列的长度"><a href="#7-9-最长的斐波那契子序列的长度" class="headerlink" title="7.9 最长的斐波那契子序列的长度"></a>7.9 <a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/description/">最长的斐波那契子序列的长度</a></h3><p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p><ul><li><code>n &gt;= 3</code></li><li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></li></ul><p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p><em>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p><p> <strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: arr = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]<br>输出: <span class="hljs-number">5</span><br>解释: 最长的斐波那契式子序列为 [<span class="hljs-number">1,2,3,5</span>,<span class="hljs-number">8</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[1,3,7,11,12,14,18]</span><br>输出: 3<br>解释: 最长的斐波那契式子序列有 <span class="hljs-comment">[1,11,12]</span>、<span class="hljs-comment">[3,11,14]</span> 以及 <span class="hljs-comment">[7,11,18]</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></li></ul><blockquote><p>思路：</p><p>朴素的遍历：每次从A中找序列的前两个数，然后在数组中查找二数之和，然后更新这两个数，继续查找。</p><p>时间复杂度： <code>O(n^2 * logn )</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        HashMap&lt;Integer ,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            map.put(arr[i], i);<br><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n ;j ++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> arr[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span>arr[j];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x1 + x2;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">while</span>(map.containsKey(sum))&#123;<br>                    x1 = x2;<br>                    x2 = sum;<br>                    sum = x1 + x2;<br>                    cur++;<br>                &#125;<br>                max = Math.max(max, cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">0</span> : max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>序列问题一般解题思路就是动态规划！</p><p>动态规划主要的两点：</p><ul><li><code>dp</code>数组的含义</li><li>状态转移方程</li></ul><p>因为枚举任何下标i，当i确定时，任何小于i的下标j都可以是斐波那契数列中的一员，所以我们要确定斐波那契数列中的最后两位数字才能确定这个斐波那契数列。</p><p>所以我们定义<code>dp</code>数组的含义为：<code>dp[j][i] 表示以arr[j] 和 arr[i]为结尾的斐波那契数列的长度即len([,,,,,arr[j],arr[i]])</code>。</p><p>那么状态如何转移的呢？</p><p>当我们能够找到一个下标k，使得<code>arr[k] = arr[i]-arr[j]</code>那么，<code>dp[j][i]  就应该等于以arr[k]和arr[j]为结尾的斐波那契数列长度再加上一个arr[i]即加1，等式：dp[j][i] = Math.max(dp[k][j]+ 1,3)这里的三是斐波那契数列最小长度为三</code></p><p>枚举j的时候要确保<code>arr[j] * 2 &gt; arr[i]</code>才能满足<code>arr[k] &lt; arr[j]</code></p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        HashMap&lt;Integer ,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            map.put(arr[i], i);<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] * <span class="hljs-number">2</span> &gt; arr[i]; j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> map.getOrDefault(arr[i]-arr[j], -<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(k == -<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[j][i] = Math.max(dp[k][j]+<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>                ans = Math.max(ans, dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-11-实现一个魔法字典（字典树）"><a href="#7-11-实现一个魔法字典（字典树）" class="headerlink" title="7.11 实现一个魔法字典（字典树）"></a>7.11 <a href="https://leetcode.cn/problems/implement-magic-dictionary/description/">实现一个魔法字典</a>（字典树）</h3><p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p><p>实现 <code>MagicDictionary</code> 类：</p><ul><li><code>MagicDictionary()</code> 初始化对象</li><li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li><li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中 <strong>一个</strong> 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]<br>[[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>]<br><br>解释<br>MagicDictionary magicDictionary = <span class="hljs-built_in">new</span> MagicDictionary();<br>magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);<br>magicDictionary.<span class="hljs-keyword">search</span>(&quot;hello&quot;); // 返回 <span class="hljs-keyword">False</span><br>magicDictionary.<span class="hljs-keyword">search</span>(&quot;hhllo&quot;); // 将第二个 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span> 可以匹配 &quot;hello&quot; ，所以返回 <span class="hljs-keyword">True</span><br>magicDictionary.<span class="hljs-keyword">search</span>(&quot;hell&quot;); // 返回 <span class="hljs-keyword">False</span><br>magicDictionary.<span class="hljs-keyword">search</span>(&quot;leetcoded&quot;); // 返回 <span class="hljs-keyword">False</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dictionary.length &lt;= 100</code></li><li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li><li><code>dictionary[i]</code> 仅由小写英文字母组成</li><li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li><li><code>1 &lt;= searchWord.length &lt;= 100</code></li><li><code>searchWord</code> 仅由小写英文字母组成</li></ul><blockquote><p>思路：</p><p><code>DFS</code>+<code>Trie</code></p><p>整体题意：给定字符串 <code>s</code>，问能否存在替换掉 <code>s</code> 中的某个字符，使得新字符串出现在 <code>ss</code> 数组中。</p><p>主要逻辑是在字典树的查询过程中</p><p>我们设计一个函数<code>dfs(String s, int idx, int p,int limit)</code>其中s表示要搜索的字符串，<code>idx</code>表示处理到字符串的下标，p表示当前搜索到的字典树的索引编号。limit表示剩余的修改次数，根据题意这里为1。</p><p>函数逻辑见代码</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>*<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[][] ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][<span class="hljs-number">26</span>];<br>    <span class="hljs-type">boolean</span>[] isEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N*<span class="hljs-number">26</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String word)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(ts[p][u] == <span class="hljs-number">0</span>) ts[p][u] = ++idx;<br>            p = ts[p][u];<br>        &#125;<br>        isEnd[p] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> limit)</span>&#123;<br>        <span class="hljs-comment">// 如果修改次数大于两次则返回失败，无法查到</span><br>        <span class="hljs-keyword">if</span>(limit &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果处理的字符串已经查询完</span><br>        <span class="hljs-comment">// 查看现在的字符是否是结尾字符并且查看limit是否已为0 ，这里题目要求必须得修改后相等才算查询到</span><br>        <span class="hljs-keyword">if</span>(idx == s.length())<span class="hljs-keyword">return</span> isEnd[p] &amp;&amp; limit == <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录当前的字母</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(idx) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            <span class="hljs-comment">// 如果字典树中没有对应的字符则跳过不处理</span><br>            <span class="hljs-keyword">if</span>(ts[p][i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 字典输有对应的字符，下标+1，如果该字符和字符串现在处理的下标字符一致，则不用修改，否则使用一次修改机会。</span><br>            <span class="hljs-keyword">if</span>(query(s, idx+<span class="hljs-number">1</span>, ts[p][i], i == u ? limit:limit-<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String str:dictionary)&#123;<br>            add(str);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(searchWord, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>TrieNode</code>实现</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">boolean</span> isEnd;<br>        Node[] ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    Node root;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String word)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length(); <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> word.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(p.ts[u] == <span class="hljs-literal">null</span>) p.ts[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            p = p.ts[u];<br>        &#125;<br>        p.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> idx, Node p, <span class="hljs-type">int</span> limit)</span>&#123;<br>        <span class="hljs-keyword">if</span>(limit &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(idx == s.length()) <span class="hljs-keyword">return</span> p.isEnd &amp;&amp; limit == <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(idx) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(p.ts[i] == <span class="hljs-literal">null</span>)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(query(s, idx+<span class="hljs-number">1</span>, p.ts[i], i == u ? limit : limit-<span class="hljs-number">1</span>) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String word:dictionary)&#123;<br>            add(word);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(searchWord, <span class="hljs-number">0</span>, root, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-12-奇数值单元格的数目"><a href="#7-12-奇数值单元格的数目" class="headerlink" title="7.12 奇数值单元格的数目"></a>7.12 <a href="https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/description/">奇数值单元格的数目</a></h3><p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p><p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p><p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p><ol><li><code>ri</code> 行上的所有单元格，加 <code>1</code> 。</li><li><code>ci</code> 列上的所有单元格，加 <code>1</code> 。</li></ol><p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png" alt="img"></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：m = <span class="hljs-number">2</span>, n = <span class="hljs-number">3</span>, indices = <span class="hljs-string">[[0,1],[1,1]]</span><br>输出：<span class="hljs-number">6</span><br>解释：最开始的矩阵是 <span class="hljs-string">[[0,0,0],[0,0,0]]</span>。<br>第一次增量操作后得到 <span class="hljs-string">[[1,2,1],[0,1,0]]</span>。<br>最后的矩阵是 <span class="hljs-string">[[1,3,1],[1,3,1]]</span>，里面有 <span class="hljs-number">6</span> 个奇数。<br></code></pre></td></tr></table></figure><blockquote><p>思路一：</p><p>直接模拟</p><p>时间复杂度 O*(<em>q</em>×(<em>m</em>+<em>n</em>)+<em>m</em>×<em>n</em>)。</p><p>空间复杂度：O (m + n)</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">oddCells</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] indices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] indice: indices)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>                matrix[indice[<span class="hljs-number">0</span>]][i]++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>                matrix[i][indice[<span class="hljs-number">1</span>]]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-13-行星碰撞"><a href="#7-13-行星碰撞" class="headerlink" title="7.13 行星碰撞"></a>7.13 <a href="https://leetcode.cn/problems/asteroid-collision/description/">行星碰撞</a></h3><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p><p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p><p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：asteroids = [5,10,-5]<br>输出：[5,10]<br>解释：10 和 -5 碰撞后只剩下<span class="hljs-number"> 10 </span>。<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 10 </span>永远不会发生碰撞。<br></code></pre></td></tr></table></figure><blockquote><p>简单的栈模拟运用：</p><p>因为碰撞只会在相邻的两颗行星之间发生，我们可以用栈来模拟该过程</p><p>从前往后遍历<code>asteroids</code>，用栈存储未抵消的行星，如果栈顶元素的方向向右（大于0），当前的<code>asteroids[i]</code>方向向左（小于0），则会发生抵消。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ast : asteroids)&#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">while</span>(ok &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peekLast() &gt; <span class="hljs-number">0</span> &amp;&amp; ast &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.abs(stack.peekLast()), b = Math.abs(ast);<br>                <span class="hljs-keyword">if</span>( a &lt;= b) stack.pollLast();<br>                <span class="hljs-keyword">if</span>( a &gt;= b) ok = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ok) stack.addLast(ast);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> stack.size();<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sz];<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) ans[--sz] = stack.pollLast();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-14-前缀和后缀搜索-字典树"><a href="#7-14-前缀和后缀搜索-字典树" class="headerlink" title="7.14  前缀和后缀搜索 (字典树)"></a>7.14  <a href="https://leetcode.cn/problems/prefix-and-suffix-search/description/">前缀和后缀搜索 </a>(字典树)</h3><p>设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。</p><p>实现 <code>WordFilter</code> 类：</p><ul><li><code>WordFilter(string[] words)</code> 使用词典中的单词 <code>words</code> 初始化对象。</li><li><code>f(string pref, string suff)</code> 返回词典中具有前缀 <code>prefix</code> 和后缀 <code>suff</code> 的单词的下标。如果存在不止一个满足要求的下标，返回其中 <strong>最大的下标</strong> 。如果不存在这样的单词，返回 <code>-1</code> 。</li></ul><blockquote><p>字典树</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordFilter</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node[] ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>        List&lt;Integer&gt; idxs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">suf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Node p, String s, <span class="hljs-type">int</span> idx, <span class="hljs-type">boolean</span> isTurn)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        p.idxs.add(idx);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> isTurn ? n - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; n; i += isTurn ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.ts[u] == <span class="hljs-literal">null</span>)<br>                p.ts[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            p = p.ts[u];<br>            p.idxs.add(idx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length(), m = b.length();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> a.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.ts[u] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            p = p.ts[u];<br>        &#125;<br>        List&lt;Integer&gt; l1 = p.idxs;<br>        p = suf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> b.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (p.ts[u] == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            p = p.ts[u];<br>        &#125;<br>        List&lt;Integer&gt; l2 = p.idxs;<br>        n = l1.size();<br>        m = l2.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, j = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (l1.get(i) &gt; l2.get(j))<br>                i--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.get(i) &lt; l2.get(j))<br>                j--;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> l1.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordFilter</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            add(pre, words[i], i, <span class="hljs-literal">false</span>);<br>            add(suf, words[i], i, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String pref, String suff)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(pref, suff);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-16-剑指-Offer-II-041-滑动窗口的平均值"><a href="#7-16-剑指-Offer-II-041-滑动窗口的平均值" class="headerlink" title="7.16 剑指 Offer II 041. 滑动窗口的平均值"></a>7.16 <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></h3><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p><p>实现 MovingAverage 类：</p><p>MovingAverage(int size) 用窗口大小 size 初始化对象。<br>double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。</p><blockquote><p>简单题使用队列来模拟这个过程就好</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingAverage</span> &#123;<br><br>    LinkedList&lt;Integer&gt; window ;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MovingAverage</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(window.size() &gt;= size)&#123;<br>            sum -= window.pollFirst();<br>            <br>        &#125;<br>        window.addLast(val);<br>        sum += val;<br>        <span class="hljs-keyword">return</span> sum / (window.size()*<span class="hljs-number">1.0</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-17-数组嵌套（写在了哈希专题）"><a href="#7-17-数组嵌套（写在了哈希专题）" class="headerlink" title="7.17 数组嵌套（写在了哈希专题）"></a>7.17 数组嵌套（写在了哈希专题）</h3><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220715144544716.png" alt="image-20220715144544716"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a><code>InnoDB</code>和<code>MyISAM</code>的区别</h4><ol><li><code>MyISAM</code> <strong>不支持行级别锁</strong>，只支持表锁。而<code>InnoDB</code>支持行锁和表锁。</li><li><code>MyISAM</code>不支持事务，<code>InnoDB</code>支持事务实现了<code>SQL</code>标准定义的四个隔离级别，具有提交和回滚事务的能力。</li><li><code>MyISAM</code>不支持外键，而<code>InnoDB</code>支持外键（一般开发不使用外键，外键和级联更适合单机开发，而不适合分布式，高并发集群。级联更新是强阻塞的，存在数据库更新风暴的危险，而外键影响插入速度）</li><li><code>MyISAM</code>不支持数据库异常崩溃后的安全恢复，而<code>InnoDB</code>支持，数据库重新启动后会保证数据库恢复到崩溃前的状态，这个过程依赖<code>redo log</code></li><li><code>MyISAM</code>不支持<code>MVCC</code>，<code>InnoDB</code>支持<code>MVCC</code>.</li><li><code>MyISAM</code>和<code>InnoDB</code>索引都是使用B+树实现。但是<code>InnoDB</code>是聚集索引（主键索引）叶子节点存储行数据，而<code>MyISAM</code>是非聚集索引即数据和索引分开（叶子节点存储地址）。</li></ol><p>**<code>MyISAM</code>更适合读密集的表，而<code>InnoDB</code>更适合写密集的的表。 *<em>在数据库做主从分离的情况下，经常选择<code>MyISAM</code>作为主库的存储引擎（最后一句有待验证，因为主库负责对外提供写服务，从库对外提供读服务）*<em>。</em></em></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p><strong>原子性</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性</strong>： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><p><strong>隔离性</strong>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p><p><strong>持久性</strong>：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p><p><code>ACID</code>的关系: <strong>只有保持了事务的原子型，隔离性，持久性之后，才能保证事务有一致性</strong></p><h4 id="事务特性的实现原理"><a href="#事务特性的实现原理" class="headerlink" title="事务特性的实现原理"></a>事务特性的实现原理</h4><h5 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h5><p>并发控制技术实现了事务的隔离性，确保一致性不会因为并发执行的操作而被破坏。</p><h5 id="日志恢复技术"><a href="#日志恢复技术" class="headerlink" title="日志恢复技术"></a>日志恢复技术</h5><p>保证了事务的原子性（回滚），使一致性不会因为事务或系统故障而被破坏。同时使已提交的对数据库的修改不会因为系统崩溃而丢失。保证了持久性。</p><h4 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h4><p>如果不考虑事务的隔离性，那么多个用户&#x2F;线程操作同一份数据时，会发生并发问题。</p><p>并发异常主要有主要有：</p><p><strong>数据丢失</strong>：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p><p><strong>脏读</strong>：读到了 <strong>未提交</strong>的数据。当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><p>读到了未提交的数据是很危险的，因为修改这个数据的事务可能会失败，而导致回滚，这样数据的一致性就不能保持。</p><p><img src="/leetcode_recod.assets/942b5358214c819180e73399355adbb888cded.png" alt="img"></p><p><strong>不可重复读</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。(<code>MVCC</code>快照读可以解决，并且可以解决快照读的幻读问题)</p><img src="../../../../SophomoreⅡ/算法/我要去字节.assets/c2688293503fa8728ce21981e402a553001cc0.png" alt="img" style="zoom:50%;" /><ul><li><p><strong>不可重复读的危害：</strong>不可重复读，是指在数据库访问中，一个事务范围内两个查询的相同记录却返回了不同数据。</p></li><li><p>例子：对账：比如某账号余额100元，该账号有两笔交易记录(+200, -100)，这样这个账号就对账正常，但如果程序查询出账号余额100元后，这时用户又转出100元，我们再去查询交易记录时，在不同事务隔离级别下会查到不同的结果，如下：</p><table><thead><tr><th>提交读</th><th>可重复读</th><th>备注</th></tr></thead><tbody><tr><td></td><td></td><td>开始时余额100，交易记录(+200, -100)</td></tr><tr><td>查询到余额100元</td><td>查询到余额100元</td><td></td></tr><tr><td></td><td></td><td>另一事务支出100元，余额减少为0，并提交</td></tr><tr><td>查询到交易记录(+200, -100, -100)</td><td>查询到交易记录(+200, -100)</td><td></td></tr><tr><td>对账失败</td><td>对账成功</td><td></td></tr></tbody></table></li><li><p>可重复读也经常用在数据库备份过程中，由于数据库备份时数据还有可能在不断修改，我们肯定希望备份整个数据库开始时的那个版本，而不希望备份的数据有些是之前那个时刻版本的，有些则是之后那个时间版本的。</p></li></ul><p><strong>幻读</strong>：幻读与不可重复读类似。它发生在一个事务<code>（T1）</code>读取了几行数据，接着另一个并发事务<code>（T2）</code>插入了一些数据时。在随后的查询中，第一个事务<code>（T1）</code>就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。(<code>MVCC</code>＋间歇锁可以解决)</p><img src="../../../../SophomoreⅡ/算法/我要去字节.assets/13a0272842a4197f3762709aa4db6c6f3fcd9f.png" alt="img" style="zoom:50%;" /><p>四个<code>SQL</code>标准的隔离级别：</p><p><strong>读未提交（RU）</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>读已提交（RC）</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p><strong>可重复读（RR）</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>可串行化（<code>SERIALIZABLE</code>）</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><img src="../../../../SophomoreⅡ/算法/我要去字节.assets/349a80a0187cefe9a99253974e47b3e7536d6f.png" alt="img" style="zoom:50%;" /><p> 表级锁和行级锁了解吗？有什么区别？</p><p><code>MyISAM </code>仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p><p><code>InnoDB </code>不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说，<code>InnoDB</code>的性能更高。</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> <code>MySQL</code> 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，<code>MyISAM 和 InnoDB </code>引擎都支持表级锁。</li><li><strong>行级锁：</strong> <code>MySQL</code> 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引——以主键的值来构建索引</p><h4 id="主索引"><a href="#主索引" class="headerlink" title="主索引"></a>主索引</h4><p>定义：将主文件分块，每一块对应一个索引项。每个存储快的第一条记录，又称为锚记录。主索引是按照索引字段值进行排序的一个有序文件，通常建立在有序文件的基于主码的排序字段上。以<code>Mysql的MyIsam存储引擎</code>为例</p><p><img src="/leetcode_recod.assets/813308fd0280b523c3397a53c5a91d7d.png" alt="img"></p><h4 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h4><p>非主键索引——以非主键值来构建索引</p><h4 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h4><ul><li>主键索引的叶子节点是存储整个行数据</li><li>非主键索引的叶子节点存储的是主键值</li></ul><h4 id="为什么非主键索引不存储数据"><a href="#为什么非主键索引不存储数据" class="headerlink" title="为什么非主键索引不存储数据"></a>为什么非主键索引不存储数据</h4><p><strong>1. 保持一致性：</strong><br>当数据库表进行<code>DML</code>操作时，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需进行更改。</p><p><strong>2. 节省存储空间：</strong><br><code>Innodb</code>数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据。</p><h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><ul><li>聚簇索引：将<a href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>与索引放到了一块，<strong>找到索引也就找到了数据</strong></li><li>非聚簇索引：将<strong>数据存储于索引</strong>分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2823867/2q05hsflfa.jpeg" alt="img"></p><h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为<strong>每次使用辅助索引检索都要经过两次B+树查找</strong>，这不是多此一举吗？聚簇索引的优势在哪？</p><ol><li>由于<strong>行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘。这样<strong>主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回</strong>了，<strong>如果按照主键Id来组织数据，获得数据更快</strong>。</li><li><strong>辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处</strong>是，<strong>减少了当出现行移动或者数据页分裂时辅助索引的维护工作</strong>，<strong>使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”<strong>。</strong>也就是说行的位置（实现中通过16K的Page来定位）会随着</strong><a href="https://cloud.tencent.com/solution/database?from=10680"><strong>数据库</strong></a><strong>里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响</strong>。</li><li>聚簇索引适合用在排序的场合，非聚簇索引不适合</li><li>取出一定范围数据的时候，使用用聚簇索引</li><li>二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据</li><li>可以把<strong>相关数据保存在一起</strong>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I&#x2F;O。</li></ol><h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol><li>聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位 置，必须在数据页中进行数据重排，降低了执行速度。</li></ol><h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" alt="img"></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志，是<code>Innodb</code>引擎独有的，它让<code>mysql</code>具有崩溃恢复能力。</p><p>比如<code>mysql</code>实例挂了或宕机了，重启时，<code>Innodb</code>存储引擎会使用<code>redo log</code>来恢复数据，保持数据的持久性和完整性。</p><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h4><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/0c9f470819684156cfdc27c682db4def.png" alt="img"></p><p><strong>为什么要三次握手：</strong></p><p>三次握手的目的是建立可靠的通信信道，即确定发送方和接收方收发正常。</p><p>第一次握手：Client什么都不能确认，Server确定自己接收正常， 对方发送正常。</p><p>第二次握手：Client确定自己发送，接收正常，对方发送，接收正常；Server确认自己接收正常， 对方发送正常。</p><p>第三次握手：Client确定自己发送，接收正常，对方发送，接收正常；Service确定自己发送，接收正常，对方发送，接收正常。</p><p><strong>改成两次握手行不行？</strong></p><p>肯定是不行，如果改成两次握手会出现：如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><p><strong>第二次握手传回了ACK，为啥还要传SYN</strong></p><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p><img src="https://camo.githubusercontent.com/790654187401ebbe3f8b7b5c25abc4e234b13a5fde546963d201e2092e964a25/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067" alt="img" style="zoom:67%;" /><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN&#x3D;1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>为什么要四次挥手</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>为什么要等两个MSL</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</li></ul><p><strong>为什么是两倍MSL呢</strong></p><p>MSL是Maximum Segment Lifetime的缩写，译为报文最大生存时间，</p><p>A并不知道B是否接到自己的ACK，A是这么想的：<br>1）如果B没有收到自己的ACK，会超时重传FIN那么A再次接到重传的FIN，会再次发送ACK<br>2）如果B收到自己的ACK，也不会再发任何消息，包括ACK<br>无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：</p><p>去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p>这恰恰就是2MSL( Maximum Segment Life)。</p><p>等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。同时也能保证网络中老的链接全部消失。</p><h3 id="TCP如何保证可靠传输（再看看课本）"><a href="#TCP如何保证可靠传输（再看看课本）" class="headerlink" title="TCP如何保证可靠传输（再看看课本）"></a>TCP如何保证可靠传输（再看看课本）</h3><ol><li>序号机制</li><li>校验和机制</li><li>流水线发送（ARQ）类似GBN和SR的集合体</li><li>累积ACK</li><li>冗余ACK快速重传机制</li><li>缓存失序包</li><li>流量控制，发送的数据不能大于流量窗口大小</li><li>拥塞控制（慢启动，拥塞避免，快速恢复）</li></ol><h3 id="TCP如何进行DDoS攻击和如何防御"><a href="#TCP如何进行DDoS攻击和如何防御" class="headerlink" title="TCP如何进行DDoS攻击和如何防御"></a>TCP如何进行DDoS攻击和如何防御</h3><p>TCP攻击可以简单的分为以下三类：</p><ol><li><p>FLOOD类攻击，例如发送海量的syn,syn_ack,ack,fin等报文，占用服务器资源，使之无法提供服务。</p></li><li><p>连接耗尽类攻击，如与被攻击方，完成三次握手后不再发送报文一直维持连接，或者立刻发送FIN或RST报文，断开连接后再次快速发起新的连接等，消耗TCP连接资源。  还有一类则比较巧妙，是在我们上述没有做分析的数据传输过程中的利用TCP本身的流控，可靠性保证等机制来达到攻击的目的。</p></li><li><p>利用协议特性攻击：例如攻击这建好连接之后，基于TCP的流控特性，立马就把TCP窗口值设为0，然后断开连接，则服务器就要等待Windows开放，造成资源不可用。或者发送异常报文，可能造成被攻击目标奔溃</p></li></ol><h3 id="DNS是使用TCP还是UDP"><a href="#DNS是使用TCP还是UDP" class="headerlink" title="DNS是使用TCP还是UDP"></a>DNS是使用TCP还是UDP</h3><p>DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？</p><p>DNS在<strong>区域传输</strong>的时候使用TCP协议，其他时候使用UDP协议。</p><p>DNS区域传输的时候使用TCP协议：</p><p>1.<strong>辅域名服务器</strong>会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p><p>2.TCP是一种可靠连接，保证了数据的准确性。</p><p>域名解析时使用UDP协议：</p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p><p>常见：</p><ul><li>200 成功</li><li>301 所请求的资源永久移动</li><li>304 所请求的资源未被修改（Web Cache）</li><li>400 Bad request 客户请求的语法错误，服务器无法理解</li><li>404 请求页面不存在</li><li>401 未进行身份认证</li><li>403 服务器理解客户请求，但是拒绝此请求的执行</li><li>405 Method Not allow 请求方法禁止</li><li>500 服务器错误</li><li>502 Bad Gateway  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET用来获取资源，它只是获取、查询数据，不会修改服务器的数据，从这点来讲，它是安全的（后面还会从另一方面分析它的不安全性）。由于它是读取的，因此可以对<code>GET</code>请求的数据进行缓存。</p><p>POST一般用来向服务器发送修改请求，或者提交表单等</p><p><code>GET</code>请求时<code>URL</code>的长度是有限制的、<code>GET</code>没有<code>body</code>而<code>POST</code>有&#96;body</p><p>在使用<code>HTTP</code>作为接口进行传输时，就没有这么多条条框框了，此时<code>GET</code>和<code>POST</code>只是<code>HTTP</code>协议中的两种请求方式，而<code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议， 无论<code>GET</code>还是<code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别。</p><ol><li>我们前面说，无论是<code>GET</code>请求还是<code>POST</code>请求，其本质都是不安全的，为什么这样说呢？如果仅仅从<code>GET</code>请求的参数在地址栏是可见的，<code>POST</code>是不可见的，那就太肤浅了。 由于<code>HTTP</code>自己本身是一个明文协议，每个<code>HTTP</code>请求和返回的数据在网络上都是明文传播，无论是<code>url</code>、<code>header</code>还是<code>body</code>。 只要在网络节点捉包，就能获取完整的数据报文，要防止泄密的唯一手段就是使用<code>HTTPS</code>（用<code>SSL</code>协议协商出的密钥加密明文<code>HTTP</code>数据）。</li><li>为什么在浏览器中<code>GET</code>请求方式的<code>url</code>长度有限制呢？这是因为浏览器要对<code>url</code>进行解析，而解析的时候就要分配内存。对于一个字节流的解析，必须分配<code>buffer</code>来保存所有要存储的数据。而<code>url</code>这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果<code>url</code>太长，而并发又很高，就容易挤爆服务器的内存。</li><li><code>POST</code>是发送两个请求吗？ 上面提到<code>POST</code>请求可以被分为“请求头”和“请求体”两个部分，那这两部分是一起发送出去呢？还是先发“请求头”，再发“请求体”呢？ 在<code>HTTP</code>协议中并没有明确说明<code>POST</code>会产生两个数据包。之所以会发两个数据包，则是出于以下考虑：如果服务器先收到“请求头”，则会对其进行校验，如果校验通过，则回复客户端“100 - Continue”，客户端再把”请求体“发给服务器。如果请求被拒了，服务器就回复个400之类的错误，这个交互就终止了。这样做的优点是可以避免浪费带宽传输请求体，但是代价就是会多一次Round Trip。如果刚好请求体的数据也不多，那么一次性全部发给服务器可能反而更好。所以说，这和<code>POST</code>完全没有关系，只是基于两端的一种优化手段罢了。</li></ol><h3 id="Http长连接和短链接"><a href="#Http长连接和短链接" class="headerlink" title="Http长连接和短链接"></a>Http长连接和短链接</h3><h4 id="长连接和短链接的优点"><a href="#长连接和短链接的优点" class="headerlink" title="长连接和短链接的优点"></a>长连接和短链接的优点</h4><p><strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。不过这里<strong>存在一个问题</strong>，<strong>存活功能的探测周期太长</strong>，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，<strong>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候</strong>，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p><h4 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a><strong>什么时候用长连接，短连接？</strong></h4><p><strong>操作频繁，点对点的通讯，而且连接数不多的情况用长连接。</strong></p><p><strong>长连接</strong>多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p><strong>并发量大，但每个用户无需频繁操作情况下需用短连接。</strong></p><p>而像WEB网站的<code>http</code>服务一般都用<strong>短链接</strong>，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><p>然而，一般Http1.1是默认长连接，故现在WEB站点的http服务也是长连接。为什么呢？</p><p>首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。</p><p>比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这就浪费了很多资源</p><p>但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。</p><h4 id="TCP怎么保持长连接，怎么知道自己的连接有没有断"><a href="#TCP怎么保持长连接，怎么知道自己的连接有没有断" class="headerlink" title="TCP怎么保持长连接，怎么知道自己的连接有没有断"></a>TCP怎么保持长连接，怎么知道自己的连接有没有断</h4><p>应用层的心跳机制<br>通过应用程序自身发送心跳包去检测连接是否正常，基本方法就是在服务器端设置一个Timer事件，在一定时间段内向客户端一个心跳数据包，若在一定时间内没有收到客户端的回应，那么就会认为客户端掉线；同样客户端在一定时间段内没有收到服务器的心跳包，则判断与服务器端连接断开。</p><p>TCP的keepalive机制<br>其实跟心跳机制大同小异，无论是客户端还是服务器端，只要有一方开启Keepalive功能后，就会在特定的时间段内发送心跳包，对端在收到心跳包后进行回复，表示自己在线。默认的Keepalive超时时间为2小时，探测次数为5次，但超时时间可以手动设置成合理的时间段。</p><h4 id="为什么HTTP设置了keep-alive就可以保持长连接"><a href="#为什么HTTP设置了keep-alive就可以保持长连接" class="headerlink" title="为什么HTTP设置了keep alive就可以保持长连接"></a>为什么HTTP设置了keep alive就可以保持长连接</h4><p>当保持长连接时，如何判断一次请求已经完成？<br><strong>Content-Length</strong><br>Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。<br>所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。</p><p><strong>Transfer-Encoding</strong><br>Transfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。</p><h4 id="HTTP-的keep-alive-和-TCP-的keep-alive有什么区别"><a href="#HTTP-的keep-alive-和-TCP-的keep-alive有什么区别" class="headerlink" title="HTTP 的keep alive 和 TCP 的keep alive有什么区别"></a>HTTP 的keep alive 和 TCP 的keep alive有什么区别</h4><ul><li>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</li><li>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</li></ul><h4 id="断点重传-x2F-断点续传"><a href="#断点重传-x2F-断点续传" class="headerlink" title="断点重传 &#x2F; 断点续传"></a>断点重传 &#x2F; 断点续传</h4><h3 id="HTTPS-加密过程"><a href="#HTTPS-加密过程" class="headerlink" title="HTTPS 加密过程"></a>HTTPS 加密过程</h3><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥S_PUB_KEY的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li><li>用S的公钥S_PUB_KEY加密C的对称加密的公钥C_key传送给S</li></ol><p>这样S传送给C的数据用C的公钥C_key加密，C用公钥C_key解密S的数据。然后用S的公钥S_PUB_KEY加密数据，传送给S，S用私钥S_PRA_KEY解密。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><ul><li>在没有CA的情况下，中间人会劫持服务器的公钥并替换为中间人的公钥。</li><li>然后客户端用中间人的公钥加密拥有队称加密的密钥C_KEY</li><li>中间人劫持后，用中间人的公钥解密，得到密钥C_KEY,再用之前劫持的服务器公钥加密传回给服务器。</li><li>这样中间人可以在客户端和服务器不知情的情况下，获取两端的信息。</li><li><strong>根本原因就是客户端不知道获取的公钥是不是权威的，或者是不是对应服务器的</strong></li></ul><h4 id="ssl需要几次握手，如何优化"><a href="#ssl需要几次握手，如何优化" class="headerlink" title="ssl需要几次握手，如何优化"></a>ssl需要几次握手，如何优化</h4><p>在HTTPS建立前，SSL需要进行 <strong>四次</strong>握手：</p><p><img src="/leetcode_recod.assets/603212-d82f0ca8d86acf1f.png" alt="img"></p><p>1、客户端请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。</p><p>2、服务端回复一种客户端支持的加密方法、一个随机数–Server random、授信的服务器证书和非对称加密的公钥。</p><p>3、客户端收到服务端的回复后利用服务端的公钥，加上新的随机数–Premaster secret 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</p><p>4、服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</p><p>此后的HTTP链接数据传输即通过对称加密方式进行加密传输。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/04/10/Docker/"/>
    <url>/2023/04/10/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>简单地说，容器是你机器上的一个沙盒进程，与主机上所有其他进程隔离</p><ul><li>是一个可运行的镜像实例。你可以使用DockerAPI或CLI创建、启动、停止、移动或删除一个容器。</li><li>可以在本地机器、虚拟机上运行或部署到云端。</li><li>是可移植的（可以在任何操作系统上运行）。</li><li>与其他容器隔离，运行自己的软件、二进制文件和配置。</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>当运行一个容器时，它使用一个隔离的文件系统。这个自定义的文件系统是由一个容器镜像提供的。由于镜像包含了容器的文件系统，它必须包含运行应用程序所需的一切–所有的依赖关系、配置、脚本、二进制文件等等。镜像还包含容器的其他配置，如环境变量、运行的默认命令和其他元数据。</p><h3 id="容器和镜像的关系"><a href="#容器和镜像的关系" class="headerlink" title="容器和镜像的关系"></a>容器和镜像的关系</h3><p>镜像创造容器。</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>Windows: 直接到[官网下载](<a href="https://docs.docker.com/desktop/install/windows-install/">Install Docker Desktop on Windows</a>)Docker Desktop.exe，无脑点击即可。</p><h3 id="部署第一个程序"><a href="#部署第一个程序" class="headerlink" title="部署第一个程序"></a>部署第一个程序</h3><p>假设你已经写好一个app，现在想通过docker部署。</p><ol><li>进入到服务器中（假装本机就是服务器）</li><li>clone仓库到服务器中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/docker/getting-started.git<br></code></pre></td></tr></table></figure><p>项目目录：</p><p><img src="/Docker.assets/image-20230403203128187.png" alt="image-20230403203128187"></p><ol start="3"><li><p>构建容器镜像</p><p>进入到app目录下，编写dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br>   <br><span class="hljs-comment">#  FROM 从哪个镜像源找：node.js：版本是18-alpine</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine <br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-comment"># 执行命令</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yarn install --production</span><br><span class="hljs-comment"># cmd命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;src/index.js&quot;</span>]</span><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>然后执行docker build构建容器镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -t 表示tag，tag为getting-started，可以通过tag索引到这个容器镜像   . 表示dockerfile的位置是当前目录。</span><br>docker build -t getting-started .<br></code></pre></td></tr></table></figure><p>然后就完成容器镜像构建了。如果在windows下，可以打开docker桌面客户端看看本机的镜像有哪些：</p><p><img src="/Docker.assets/image-20230403203418481.png" alt="image-20230403203418481"></p><p>命令行的话，可以用<code>docker images</code>来看本机的镜像列表</p></li><li><p>运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># run 表示执行 tag=getting-started的镜像的容器。-d表示分离模式（后台进程启动） -p表示端口的映射：映射主机的端口和容器的端口</span><br>docker run -dp 3000:3000 getting-started<br><span class="hljs-comment"># 如果-p 8080:3000那么主机的8080端就会映射到容器的3000端口，访问时就是localhost:8080</span><br></code></pre></td></tr></table></figure><p>现在可以启动容器，并且访问<a href="http://localhost:3000/">http://localhost:3000</a> 。就可以访问到这个app。</p></li><li><p>查看容器</p><p>Windows直接通过docker desktop就可以看到</p><p><img src="/Docker.assets/image-20230403204228403.png" alt="image-20230403204228403"></p><p>其它系统可以执行docker命令<code>docker ps</code>就可以看到运行的容器列表</p></li></ol><h3 id="上传镜像到docker-hub"><a href="#上传镜像到docker-hub" class="headerlink" title="上传镜像到docker hub"></a>上传镜像到docker hub</h3><ol><li>注册docker hub</li><li>在docker hub 上创建一个repo</li><li>更改你的image tag 为 USER_NAME&#x2F;TAG_NAME</li></ol><p><img src="/Docker.assets/image-20230403213901519.png" alt="image-20230403213901519"></p><h3 id="持久化（容器数据卷）"><a href="#持久化（容器数据卷）" class="headerlink" title="持久化（容器数据卷）"></a>持久化（容器数据卷）</h3><p>我们知道，容器的启动是由镜像定义开始的，我们可以通过容器创建，修改，删除文件，但是当该容器删除的时候，这些变化就会消失。所有变化都隔离在容器之中，不会相互影响。</p><p>而数据卷（Volume），就是容器持久化数据的一个结构。它能够链接一个容器的特殊文件系统路径到主机中，如果容器的某个目录被挂载到主机中，那么这个目录的修改对主机也可见，如果容器间挂载了相同的数据卷，那么他们可以看见相同的文件。</p><p>把卷挂载想象成一个不透明的数据桶。Docker完全管理这个卷，包括它在磁盘上的存储位置。你只需要记住卷的名字。</p><p>创建卷的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume create todo-db<br></code></pre></td></tr></table></figure><p>接着启动容器，并绑定挂载的卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -dp 3000:3000 --mount <span class="hljs-built_in">type</span>=volume,src=todo-db,target=/etc/todos getting-started<br></code></pre></td></tr></table></figure><p>当使用卷时，docker把卷都创建在哪里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$docker</span> volume inspect todo-db<br>[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2019-09-26T02:18:36Z&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/todo-db/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;todo-db&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>其中Mountpoint就是挂载点，挂载在这个目录中。</p><p>还有另一种挂载卷的方式叫做绑定挂载（bind）</p><p>绑定挂载是另一种类型的挂载，它允许你从主机的文件系统中共享一个目录到容器中。当在一个应用程序上工作时，你可以使用绑定挂载来挂载源代码到容器中。一旦你保存了一个文件，容器就会立即看到你对代码所作的修改。<strong>这意味着你可以在容器中运行进程，观察文件系统的变化并对其作出反应</strong>。</p><p><img src="/Docker.assets/image-20230405172109918.png" alt="image-20230405172109918"></p><h3 id="部署多个容器的APP"><a href="#部署多个容器的APP" class="headerlink" title="部署多个容器的APP"></a>部署多个容器的APP</h3><p><img src="/Docker.assets/multi-app-architecture.png" alt="Todo App connected to MySQL container"></p><p>对上述说的TODO-APP进行扩展，使其能将数据存到MySQL中。一般来说一个容器只做一件事，所以TODO-APP和MySQL应该部署到两个容器里。</p><p>那么问题来了。两个容器如何进行交流呢？容器和容器之间是互相隔离的呀。</p><p>docker提供了一个network，网络的机制</p><ul><li>创建一个network。</li><li>启动容器的时候绑定这个network。</li><li>将其它容器连接到这个network中。</li></ul><p>创建network的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create todo-app<br></code></pre></td></tr></table></figure><p>创建mysql容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d `<br>     --network todo-app --network-alias mysql `<br>     -v todo-mysql-data:/var/lib/mysql `<br>     -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=secret `<br>     -e <span class="hljs-attribute">MYSQL_DATABASE</span>=todos `<br>     mysql:8.0<br></code></pre></td></tr></table></figure><p>连接到mysql</p><p>这里启动了另一个容器 <code>nicolaka/netshoot</code></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--network todo-app nicolaka/netshoot</span><br></code></pre></td></tr></table></figure><p>运行app</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -dp 3000:3000 `<br>   -w /app -v <span class="hljs-string">&quot;<span class="hljs-variable">$(pwd)</span>:/app&quot;</span> `<br>   --network todo-app `<br>   -e <span class="hljs-attribute">MYSQL_HOST</span>=mysql `<br>   -e <span class="hljs-attribute">MYSQL_USER</span>=root `<br>   -e <span class="hljs-attribute">MYSQL_PASSWORD</span>=secret `<br>   -e <span class="hljs-attribute">MYSQL_DB</span>=todos `<br>   node:18-alpine `<br>   sh -c <span class="hljs-string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span><br></code></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p>docker compose的方式实现上述过程：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">node:18-alpine</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">sh</span> <span class="hljs-string">-c</span> <span class="hljs-string">&quot;yarn install &amp;&amp; yarn run dev&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3000</span><span class="hljs-string">:3000</span><br>    <span class="hljs-attr">working_dir:</span> <span class="hljs-string">/app</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./:/app</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_HOST:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">secret</span><br>      <span class="hljs-attr">MYSQL_DB:</span> <span class="hljs-string">todos</span><br><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">todo-mysql-data:/var/lib/mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">secret</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">todos</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">todo-mysql-data:</span><br></code></pre></td></tr></table></figure><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>dockers理念：将应用和环境打包成镜像。</p><p>数据不应该在容器中，因为删除容器会导致数据的丢失。</p><p><strong>需求：数据可以存储在本地，容器之间有数据共享的技术</strong></p><p>Docker容器中产生的数据，同步到本地。这就是卷技术</p><p>即目录的挂载，将容器的目录，挂载到宿主机（linux）。</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote><p>方式一： 使用命令挂载 -v</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -v 主机目录：容器内目录 <br>docker inspect 容器<span class="hljs-built_in">id</span> <span class="hljs-comment"># 查看容器状态</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220324205348100.png" alt="image-20220324205348100"></p><blockquote><p>Source : 宿主机内地址</p><p>destination： docker容器内地址</p></blockquote><p>同步结果：</p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220324205707700.png" alt="image-20220324205707700"></p><p>好处： 修改数据只需要本地修改即可，容器会自动同步</p><h3 id="实战：安装mysql"><a href="#实战：安装mysql" class="headerlink" title="实战：安装mysql"></a>实战：安装mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取镜像</span><br>docker pull mysql:5.7<br><span class="hljs-comment"># -p 端口</span><br><span class="hljs-comment"># -v 卷挂载</span><br><span class="hljs-comment"># -d 后台启动</span><br><span class="hljs-comment"># -</span><br>[wuyuda@DESKTOP-17Q81L8]:/home$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<br><span class="hljs-comment"># 启动成功后</span><br><span class="hljs-comment"># sqlyog连接到服务器的3310 ----- 3310和容器里的3306映射，这个时候我们就连接上了</span><br><br><span class="hljs-comment"># 本地测试创建数据库，查看映射路径是否同步。</span><br><br></code></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">匿名挂载</span><br>-v 容器内的路径<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有卷的情况</span><br>docker volume ls #如果是匿名的则volume name是一堆乱码，如果是具名的就有具体的名称<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-v 时只写了容器内的路径，没有写容器外的路径</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">具名挂载</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name nginx001 -v juming-nginx:/etc/nginx nginx</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220324213745057.png" alt="image-20220324213745057"></p><p>所有docker容器内的卷，没有指定目录的i情况下都是在：<code>/var/lib/docker/volumes</code>里</p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220324213910085.png" alt="image-20220324213910085"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">确定具名挂载还是匿名挂载，还是指定路径挂载</span><br>-v 容器内路径 # 匿名挂载<br>-v 卷名：容器内路径 # 具名挂载<br>-v /宿主机路径：容器内路径 # 指定路径挂载<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name nginx001 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -P --name nginx001 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ro 只读</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rw 可读可写</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一旦设定了ro/rw，容器对挂载的内容就有限定。</span><br><br></code></pre></td></tr></table></figure><p> 初识DockersFile</p><p>DockerFile就是用来构建docker 镜像的构建文件。就是一段命令脚本。</p><p>通过这个脚本可以生成镜像。镜像是一层一层的，脚本是一个一个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建docker file文件 文件内容是 指令（大写） 参数</span><br>dockerfile01：<br>1 FROM centos<br>2<br>3 VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 匿名挂载<br>4<br>5 CMD echo &quot;------end-------&quot;<br>6 CMD /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行命令</span><br>docker build -f ./dockerfile1 -t wuyuda/centos .<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325230129720.png" alt="image-20220325230129720"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动自己写的镜像</span><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325230431934.png" alt="image-20220325230431934"></p><p>这个卷和外部一定有一个同步的目录。对应容器外的目录如下：（通过inspect命令查看）</p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325230632781.png" alt="image-20220325230632781"></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>多个mysql同步数据。同步的是挂载的文件。</p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325231124957.png" alt="image-20220325231124957"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动3个容器</span> <br>多个容器实际上操作同一个文件（即挂载的文件）<br></code></pre></td></tr></table></figure><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325231319178.png" alt="image-20220325231319178"></p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325231434637.png" alt="image-20220325231434637"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除dockers01 ， docker02仍然可以访问挂载的数据卷。</span><br></code></pre></td></tr></table></figure><p> <strong>结论：</strong><br>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p><p>但是一旦持久化到本地， 这个时候，本地的数据是不会删除的。</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>dockerfile是用来构建docker镜像的文件。</p><p>构建步骤：</p><ol><li>编写一个dockerfile文件</li><li>docker build 构建镜像</li><li>docker run</li><li>docker push 发布镜像（dockerHub）</li></ol><h3 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h3><p><img src="/Docker.assets/pic2.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto" alt="img"></p><p>基础知识：</p><ol><li>每个保留关键字（指令）都必须是大写字母。</li><li>指令是从上到下顺序执行。</li><li>#标识注释</li><li>每一个指令都会创建提交一个新的镜像层。并提交。</li></ol><h3 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM  # 基础镜像，一切从这里开始构建<br>MAINTAINER # 镜像是谁写的，留姓名+邮箱<br>RUN# 镜像构建的时候需要运行的而明亮<br>ADD# 步骤：搭建tomcat镜像， 加个tomcat的压缩包（添加的内容）<br>WORKDIR# 镜像的工作目录<br>VOLUME# 设置容器卷，挂载主机的目录。<br>EXPOSE# 指定对外暴露的端口。 -p<br>CMD# 指定这个容器启动时要运行的命令。只有最后一个会生效，可被替代。<br>ENTRYPOINT# 指定这个容器启动时要运行的命令。可以追加命令。<br>ONBUILD# 当构建镜像被继承 DockerFile 这个时候就会执行ONBUILD指令。<br>COPY # 类似ADD，将文件拷贝到镜像中。<br>ENV# 构建的时候设置环境变量。<br></code></pre></td></tr></table></figure><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F21080125-0c8ad804046861dc.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650814207&t=1ca54e48e1c7e91dd85f44ca9d86d8aa" alt="img"></p><h3 id="实战：构建自己的centos"><a href="#实战：构建自己的centos" class="headerlink" title="实战：构建自己的centos"></a>实战：构建自己的centos</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编写构建文件</span><br>root@DESKTOP-17Q81L8:/home/dockerFile# vim myDockerFile-centos<br>root@DESKTOP-17Q81L8:/home/dockerFile# cat myDockerFile-centos<br>FROM centos<br>MAINTAINER wuyuda&lt;1286360646@qq.com&gt;<br><br>ENV MYPATH /usr/local<br>WORKDIR $MYPATH<br><br>RUN yum -y install vim<br>RUN yum -y install net-tools<br><br>EXPOSE 80<br><br>CMD echo $MYPATH<br>CMD echo &quot;------end------&quot;<br>CMD /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过这个文件构建镜像</span><br>docker build -f myDockerFile-centos -t mycentos:0.1 .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动镜像</span> <br><br></code></pre></td></tr></table></figure><p>构建成功如下</p><p><img src="C:\Users\d1286\AppData\Roaming\Typora\typora-user-images\image-20220325235251600.png" alt="image-20220325235251600"></p><p>Dockerfile详解与镜像发布<a href="https://blog.csdn.net/huangjhai/article/details/120278039">https://blog.csdn.net/huangjhai/article/details/120278039</a></p><h2 id="Docker-网络原理"><a href="#Docker-网络原理" class="headerlink" title="Docker 网络原理"></a>Docker 网络原理</h2><h2 id="IDEA整合Docker"><a href="#IDEA整合Docker" class="headerlink" title="IDEA整合Docker"></a>IDEA整合Docker</h2><h2 id="Docker-Compose（集群）"><a href="#Docker-Compose（集群）" class="headerlink" title="*Docker Compose（集群）"></a>*Docker Compose（集群）</h2><h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="*Docker Swarm"></a>*Docker Swarm</h2><h2 id="CI-x2F-CD-Jenkins"><a href="#CI-x2F-CD-Jenkins" class="headerlink" title="* CI&#x2F;CD Jenkins"></a>* CI&#x2F;CD Jenkins</h2><p>CI(Continuous integration，中文意思是持续集成)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对CI加以理解。</p><p>CD(Continuous Delivery， 中文意思持续交付)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI&#x2F;CD 的大概工作模式。</p><p><img src="D:\JAVA\docerk.assets\v2-924ffb906a47387457e5eeff3fcaae08_720w.webp" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/06/hello-world/"/>
    <url>/2023/04/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
